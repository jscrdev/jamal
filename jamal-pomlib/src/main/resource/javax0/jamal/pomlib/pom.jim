This file defines the macros that can be used to set up a pom.xml.jam file.

This is a file imported and everything that is not a macro, like this text, will be discarded by Jamal, thus it is
essentially comment.
------------------------------------------------------------------------------------------------------------------------
The macros can handle optional parameters, like GAV that stands for GroupId, ArtifactId Version, but it also can handle
scope optionally. Therefore the use of these macros is lenient.
{@options lenient}
------------------------------------------------------------------------------------------------------------------------
you start a project definition with the name and at the end of the file there is an [end project].
{@define project($name)=
  <project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
                 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <name>$name</name>}
------------------------------------------------------------------------------------------------------------------------
Tags that contain a lot of elements inside are supported by macros that start only the tag. These tags have to be closed
with an [end tag] element. For example

[project name]

  the whole content of the jamalified pom file

[end project]

{@define end($x)=</$x>}
------------------------------------------------------------------------------------------------------------------------
This is an auxiliary macro and not used in the pom.xml.jam files. This macro, when invoked defines a simple macro that
will, when used generate an XML tag.

{@define tag($x)={@define $x($y)=<$x>$y</$x>}}

{@define $forsep=\s*,\s*} this lets us to split the list of the tags into multiple lines

Define all the macros that are to be used as XML tags. After that instead of writing

                   <long_tag_nam>some long content</long_tag_name>

you write [long_tag_nam some long content] (where [ and ] are the actual macro brackets).

Because the macro "eval" is preceded with the character # first the macro "for" is evaluated
the result (output) of the macro "for" is a series of "define" macros. Each defines a new macro
with the name of the tag. When this is ready then this output is processed by the macro "eval"
essentially executing the "define" macros and at this point the tags are defined as macros.

{#eval {@for _tag in (packaging,groupId,artifactId,version,scope,
                      description,url,properties,build,pluginManagement,
                      plugins,plugin,dependencyManagement,dependencies,
                      scm,connection,developerConnection,executions,
                      execution,id,goals,goal,release,configuration,
                      source,target,encoding,excludes,exclude,
                      annotationProcessorPaths,annotationProcessorPath,
                      annotationProcessors,annotationProcessor,
                      profiles,profile,
                      resources,resource,
                      directory,filtering,
                      repositories,argLine)=
{tag _tag}}}
------------------------------------------------------------------------------------------------------------------------
{@define repository($id,$url)=<repository><id>$id</id><url>$url</url></repository>}
{@define profile($id)=<profile><id>$id</id>} end a profile with an [end profile]
------------------------------------------------------------------------------------------------------------------------

The GAV macro can be used to define groupId, artifactId and version tags for the project. Each of the elements may be
missing, it is checked by the macro definitions using the 'if' macro. It is recommended to use : as argument separators
for this macro in the pom.xml.jam

The macro also defines the user defined macros GROUP_ID, ARTIFACT_ID and VERSION that is used by other macros, like
parent, when the group id, artifact id or version is not defined. Usually the parent has the same groupId and version
as a subproject.

To skip the groupId, for example, you can write [GAV ::artifa-ct:1.0.0]

{@define GAV($groupId,$artifactId,$version)=
    {#if|$groupId|{groupId $groupId}}{@define GROUP_ID=$groupId}
    {#if|$artifactId|{artifactId $artifactId}}{@define ARTIFACT_ID=$artifactId}
    {#if|$version|{version $version}}{@define VERSION=$version}
}

------------------------------------------------------------------------------------------------------------------------

{@define parent($groupId,$artifactId,$version)=<parent>
    {groupId {#if|$groupId|$groupId|{GROUP_ID}}}
    {#if|$artifactId|{artifactId $artifactId}|{artifactId {ARTIFACT_ID}}}
    {#if|$version|{version $version}|{version {VERSION}}}
</parent>}

------------------------------------------------------------------------------------------------------------------------
Define a dependency. The arguments are the ... you see. Each of the arguments are
optional. If one is missing there will be no corresponding XML tag generated.

{@define dependency($groupId,$artifactId,$version,$scope)=
<dependency>
    {#if|$groupId|{groupId $groupId}}
    {#if|$artifactId|{artifactId $artifactId}}
    {#if|$version|{version $version}}
    {#if|$scope|{scope $scope}}
</dependency>
}