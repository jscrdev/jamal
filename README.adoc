:imagesdir: images
:jamal_home: https://github.com/verhas/jamal/
//DO NOT EDIT THIS FILE; THIS IS GENERATED FROM README.adoc.jam


= image:logo.svg[width=100px] Jamal Macro Language

Jamal is a meta markup language enhancing the features of Asciidoc, Markdown, XML, JSON, YAML, JavaDoc, and any other markup languages.
It can work as a preprocessor or integrated into the toolset of the editing/processing interactively or in batch mode.
The conversion is done as a preprocessing step prior to the markup processing, the use of Jamal is non-invasive.
It can be inserted into any tool chain without risk, as it can also be removed any time.

TOC

. <<Installation,Installation, and Usage>>
. <<GS,Getting Started / Quick Start>>
. <<Configuration,Configuration>>
. <<Features,Features>>
. <<Contributing,Contributing>>
. <<Documentation,Documentation>>
. <<License,License>>
. <<Changelog,Changelog>>
. <<Roadmap,Roadmap>>
. <<Authors,Authors>>
. <<Acknowledgments,Acknowledgments>>
. <<Support,Support>>
. <<FAQ,FAQ>>

[cols="a,a,a", frame=none, grid=none]
|===
|image::jetbrains.svg[Supported,link="https://www.jetbrains.com",width=50px, alt="JetBrains"] Developed using https://www.jetbrains.com/community/opensource/#support[JetBrains OSS License]
|image::https://javadoc.io/badge/com.javax0.jamal/jamal-parent.svg[link=https://javadoc.io/doc/com.javax0.jamal]
|image:{jamal_home}actions/workflows/jamal-build.yml/badge.svg[Java CI with Maven,link={jamal_home}actions/workflows/jamal-build.yml]
|===


NOTE: This is the latest development documentation.
This is a SNAPSHOT version (2.3.1-SNAPSHOT).
 If you want to read the latest release, please visit link:{jamal_home}/tree/v2.3.0[Jamal 2.3.0]



[[Installation]]
== Installation, and Usage

Jamal is implemented as a Java library and it is embedded in different applications.
It can be used as a command line tool, as a Maven plugin, as a Maven extension, as a JavaDoc doclet, as a JShell script, as a JBang script, as a Java library, and as a JSR223 script engine.
The installation may be as simple as starting it from the command line (JBang) when the embedding application is already installed.

In the following sections, we will discuss how to install and use Jamal in the different applications it is embedded in.

. <<MavenPlugin, Maven Plugin>>
. <<MavenExtension, Maven Extension>>
. <<Starting Command Line Version, Starting Command Line Version>>
. <<Starting with JBang, Starting with JBang>>
. <<ASCIIDOC, IntelliJ, AsciidocFx>>

[[MavenPlugin]]
==== Maven Plugin

You can start Jamal from Maven as a plugin.
The plugin is available in the Maven Central repository.

To do that, you have to have Maven installed.
Having that you can issue the command:

[source]
----
mvn com.javax0.jamal:jamal-maven-plugin:2.3.1-SNAPSHOT:jamal
----

if you have a `pom.xml` file in your directory.

If you do not have, then read the documentation of the Jamal Maven plugin at
link:jamal-maven-plugin/README.adoc[Jamal Maven Plugin README].
It is short and straightforward.

[[MavenExtension]]
==== Maven Extension

You can use Jamal macros to maintain your Maven POM files.
Move the content of the POM XML in the file `pom.jam` and extend it freely with Jamal macros.
Create a `.mvn` directory with an `extensions.xml` file in your project root.

[source,xml]
---
<?xml version="1.0" encoding="UTF-8"?>
<extensions>
    <extension>
        <groupId>com.javax0.jamal</groupId>
        <artifactId>jamal-maven-extension</artifactId>
        <version>2.3.1-SNAPSHOT</version>
    </extension>
</extensions>
---

Next time you start Maven, it will include Jamal in the processing chain.
It will also generate the `pom.xml` files from the `pom.jam` files, so your IDE and other tolls that depend on the XML format keep working.

For more information about the Maven extension, read the link:jamal-maven-extension/README.adoc[documentation].

==== Starting Command Line Version

The repository contains the `jamal.sh` shell script that can be used to start Jamal from the command line.
It assumes that the libraries are already installed in the local Maven repository.
After that, you can type:

  ./jamal.sh

that will show you a short usage message:

[source,text]
----
Usage: jamal [options] input output
  -help                      help
  -shcnf                     show the configuration values from ~/.jamal/settings.(properties|xml)
  -version                   display version
  -verbose                   print out the conversions
  -open=<macroOpen>          the macro opening string
  -close=<macroClose>        the macro closing string
  -depth=<depth>             directory traversal depth, default is infinite
  -debug=<debug>             type:port, usually http:8080
  -include=<include>         file name regex pattern to include into the processing
  -exclude=<exclude>         file name regex pattern to exclude from the processing
  -source=<sourceDirectory>  source directory to start the processing
  -target=<targetDirectory>  target directory to create the output
  -from=<regex>              pattern for the file name transformation.
  -to=<replacement>          replacement for the file name transformation.
  -dry-dry-run               run dry, do not execute Jamal
  -dry-run                   run dry, do not write result to output file
  -docx                      treat the input as a docx, Microsoft Word file


----

For more information about the command line version, read the link:jamal-cmd/README.adoc[documentation].

==== Starting with JBang

JBang (https://www.jbang.dev) is a popular command line tool that eases the startup of Java applications.
Jamal can be started using JBang.
This is the recommended way to run Java from the command line if you have limited experience with Java.
When running Jamal using JBang, Jbang will install everything that is needed to execute Jamal in a clean and non-intrusive way.

JBang installaton is described on the documentation link:https://www.jbang.dev/documentation/guide/latest/installation.html[page] of JBang.

To start Jamal when you have JBang installed on your machine type:

[source,bash]
----
jbang jamal@verhas ... options ...
----

This command will invoke the command line version automatically.
The syntax and meaning of the options are the same as in case of the command line version.
This startup also loads all the safe Jamal extensions, including `snippet`, `plantuml`, and `debug` and some others.
,
If you want to see the exact list of the modules this startup loads have a look at the link:jbangstarter.java[starter] file.

[NOTE]
====
If you have used Jamal with jbang before, then jbang will store its catalog file in the local cache.
When you start Jamal using `jbang jamal@verhas ...` and you see an old version starting, then delete the file

```
~/.jbang/cache/urls/d917b991facb86b9860fa179df2c804fc2090cc76a83fb15b49f47cc2e885f7c/jbangstarter.java
```

After that, you can start jbang again.
It will download the new catalog, always pointing to the latest release.
You will find the command that deletes this file in the root of the project in the shell script `jbang-cache-evict`.
====

[[ASCIIDOC]]
=== IntelliJ, AsciidocFx

Using Jamal in IntelliJ together with Asciidoctor plugin is fairly easy.
All you have to do is download a ZIP file from the Maven repository and explode it into a directory.
The details are described in the link:jamal-asciidoc/README.adoc[documentation].

When the installation is done, all you need to do is start IntelliJ and open the project.
You can edit your Asciidoc files, and the plugin will automatically invoke Jamal to process the macros.

If you want to use AsciidocFX, the same package should be used.
The installation is similar, downloading the ZIP file and extracting it to a directory.
The detailed documentation is in the link:jamal-asciidoc/README.adoc[documentation].

[[GS]]
== Getting Started / Quick Start

You can start using Jamal in five minutes as described in link:documentation/TUTORIAL-5min.adoc[the tutorial], __"Starting with Jamal in 5 minutes"__.

[[Configuration]]
== Configuration

Jamal has a lot of configuration parameters, but each of these has reasonable default values.
It means that you do not need to configure Jamal before using it.
Configuration is needed only when you want to change some of the default values, or use a macro package that without configuration could pose a security risk.

Configuration values can be set in the following ways:

. Using system properties
. Using environment variables
. Using a configuration file in the user's home directory (`~/.jamal`)

The configuration values are searched for in this order.
Different macros use different configuration keys.
They are documented along with the macro documentation.

[[Features]]
== Features

Jamal is a meta markup language that extends existing markup languages in a transparent way.
The language is designed so that it will not interfere with any existing or future markup.

image::text2text.png[align=center]

The original markup, for example, Asciidoc or Markdown is responsible for formatting and semantic definition of the text.
Jamal will do the extra task, which is not or in some case only partially supported by the document markup.
Without Jamal or some other similar tools, these tasks are performed manually.

Jamal can

* collect information from source code and other non-document files,

* transform the collected information to fit

** the document markup,
** the document format, and
** the document semantics.

Jamal can include other files, parts of files, number the included lines, filter lines, replace part of the lines, reorder lines and many other things as needed.

.Philosophy
> When information exists in the documented system, or in the documentation, it must not be manually copied.
The copy and the transformation of the information must be automated.

Jamal is implemented in Java.
You can write user defined macros in Jamal itself and built-in macros in Java, Kotlin or in other JVM languages.

You can execute Jamal from Maven, Javadoc, CLI, AsciiDocFX, IntelliJ, and other applications.
Jamal is extensible with multiple different SPIs.
One such SPI is the debugging interface.
The library includes a debugger that you can use via a React.js web client to debug the macro evaluations step-by-step.

The library comes with more than 200 macros for different purposes.
The macros are grouped into modules.
The largest module is the document maintenance module (snippet macros), but there are modules to handle

* JSON,

* YAML,

* XML, and other data formats.

The use of Jamal makes it possible to include automatically generated images, for example, from PlantUML, Graphviz, or other tools into any markup-formatted document.
You can also include programmatic formatting and content calculation using Groovy, Ruby, and other languages.

[[Contributing]]
== Contributing

Jamal is an open-source project, and the developers welcome any contribution.
We treat all suggestions, requests, comments or any other contribution as with respect.

=== Use and Feedback

First and foremost, you can contribute by using Jamal and giving feedback.
Start using it and tell us what you like and what you do not like.
A program without users is not a program.
If you use Jamal, you are a contributor, and if you wish, we will include you as a reference in the documentation.

=== Documentation

You can contribute to Jamal reading the documentation.
If you find a typo, a mistake, or something that is not clear, please tell us.
The best way is forking the project, fixing the documentation, and sending us a pull request.
Even a single character correction is welcome as a full-blown pull request.

You can also write documentation.
Writing documentation is a huge task, and we are happy to accept any help.
We are gravely missing, for example, "How to" tutorials.
Why?
Because as developers, we develop Jamal first and our use is limited to the use cases we have.
We are not using Jamal in the same way as you do.

Every use is different, write about it.

Jamal supports the JSR223 standard.
That way Jamal can be used in any JSR223 compliant application that may need scripting.
The macro opening and closing strings are `{` and `}` in this case unless the script attributes `open` and `close` are set.
Script bindings are put into Jamal macros and are loaded from Jamal macros after execution.
We would love a tutorial describing this feature.

=== Articles

If you find Jamal fascinating, you can write an article about it.
We have experience writing and publishing articles, and we can help you.
We also write articles, but we cannot write your article.

Help us spread the word.

=== Conference

Talk about Jamal at conferences.
Give a talk or just mention it in your presentation.
Or just mention it at the coffee break or other social events.

=== Find bugs

If something does not work as you expect, please tell us.
It may be a code bug, or it may be a documentation bug.

It is NEVER a user error.
If it works as _we_ expect and not as _you_ expect, then it is a bug in the documentation.

Use the GitHub issue tracker to report bugs.
If you can locate the bug in the code and have a suggestion to fix it, then you can also send us a pull request.

=== Suggest Features

If you miss a feature, please tell us.
We will consider it, and if it is a good idea, we will implement it.
If you can implement it, then send us a pull request.

=== Create Macro Libraries

Jamal can be extended with new macros.
Create your own macros for your own use.
If you think that your macros are useful for others, then create a new module and publish it.
We will be happy to reference it in the Jamal project.

[[Documentation]]
== Documentation

Since Jamal is a complex program, the documentation is split into several parts.
The modules, each has its documentation in the form of a README file in the module directory.
Jamal is eating its own dog food, so the documentation is written in Jamal and Asciidoc0.

Here we will link the different documentation parts.

=== Debugger

The debugger is a web-based, interactive tool using React.js.
There is no separate documentation describing where to click and how to use it.
The existing documentation describes the debugging architecture and how to start Jamal in debug mode.

Anyway, here is a screenshot of the debugger in action:

image::jamaldebugger2559x1089.png[]
* link:./jamal-debug/README.adoc#[Debugger Technical Documentation]

=== Applications, Embedding

* link:./jamal-asciidoc/README.adoc[Jamal Asciidoc Documentation], How to configure and use Jamal to edit Asciidoc files using IntelliJ editor in a WYSIWYG way, or the AsciiDocFX editor.
* link:./jamal-doclet/README.adoc[Jamal Doclet Documentation], How to use Jamal in JavaDoc.
* link:./jamal-maven-plugin/README.adoc[Jamal Maven Plugin README], How to use Jamal as a Maven plugin.
* link:./jamal-maven-extension/README.adoc[Jamal Maven Extension README], How to use Jamal as a Maven extension.


=== Programming Language Modules


* link:./jamal-ruby/README.adoc#[Ruby Module README], How to use Ruby code in your Jamal source
* link:./jamal-groovy/README.adoc#[Groovy Module README], How to use Groovy code in your Jamal source
* link:./jamal-scriptbasic/README.adoc#[ScriptBasic Module README], How to use ScriptBasic code in your Jamal source
* link:./jamal-prog/README.adoc#[Prog Module README], How to use Prog code in your Jamal source is a simple BASIC like languagen tightly integrated with Jamal.

=== Other External Modules

* link:./jamal-io/README.adoc[Io Module README], How to read and write external files from Jamal macros
* link:./jamal-jamal/README.adoc[Jamal Jamal Module README], How to use Jamal inside Jamal as an embedded language
* link:./jamal-markdown/README.adoc[Jamal Markdown Module README], Convert markdown to HTML, main usable together with the Jamal Doclet to have Markdown in JavaDoc
* link:./jamal-mock/README.adoc[Jamal Mock Module README], Mock built-in macros to test macros that are to run in a specific environment
* link:./jamal-plantuml/README.adoc[Jamal PlantUML Module README], Embed PlantUML pictures into your documentation
* link:./jamal-snippet/README.adoc[Jamal Snippet Module README], Use snippets to compile your documentation
* link:./jamal-yaml/README.adoc[Jamal Yaml Module README], Use data from Yaml files in your macros and use macros in your Yaml files
* link:./jamal-json/README.adoc[Jamal JSon Module README], Use data from JSON files in your macros and use macros in your JSON files
* link:./jamal-assertions/README.adoc[Jamal Assertions Module README], contains macros to make assertions to ensure the consistency of your documentation
* link:./jamal-word/README.adoc[DOCX Word Processing README], describes the Jamal Microsoft Word Processing module and the macros that are specific to DOCX processing

=== Test Support

* link:./jamal-testsupport/README.adoc[Jamal Test Module README], Use this module to test your own Java or Kotlin implemented macros.

[[License]]
== License

Jamal is distributed under the Apache 2.0 license.

[[Changelog]]
== Changelog

Jamal uses GitHub.
The change log is maintained online in the link:https://github.com/verhas/jamal/releases[GitHub releases page].
There is also a link:RELEASES.adoc[local copy] of the release notes.

[[Roadmap]]
== Roadmap

The roadmap is maintained in the document: link:RODMAP.adoc[ROADMAP].
It is more like a collection of ideas and plans than a strict roadmap.

[[Authors]]
== Authors
[[Acknowledgments]]
== Acknowledgments
[[Support]]
== Support

Jamal is an open source project and currently not backed by any company.

[[FAQ]]
== FAQ

See the separate document: link:FAQ.adoc[FAQ].


== Table of contents

. <<Starting,Starting Jamal>>
. <<SimpleExample,Simple Example>>
. <<OtherMacros,Core Built-in Macros>>
. <<argsplit,Macro Argument Splitting>>
. <<parparsing,Standard Built-In Parameter Parsing>>
. <<JamalENV,Jamal Environment Variables>>
. <<httpsres,Resource Files and Web Resources>>
. <<error_messages,Error Messages>>
. <<snippet,Snippet Handling>>
. <<Groovy,Groovy Integration>>
. <<Ruby,Ruby Integration>>
. <<JamalAPI,Jamal API>>
. <<javadoc,JavaDoc>>
. <<documentmaintenance,Maintenance of this document>>




==== Debugging Macro Conversions

When something goes wrong, Jamal gives you a detailed error message.
The message will include the file name, line number, and character count where the error happened.
In other cases, Jamal may think it works fine, but the output is not exactly what you expected.
Sorry, in this case, the issue, most probably, is with your expectations.

In cases like that, you can try to debug the execution of the macro engine.
There are two possibilities:

. use the trace functionality, or
. use the debugger.

The trace functionality can create a detailed XML trace of the execution that can later be examined.
The trace information is structured with nested structures.
XML is a format that can accommodate such nested structures and has very extensive editor support.

The debugging functionality can execute the macro transformation step-by-step providing interactive debugger user interface.
The tracing functionality was developed earlier, and its importance lessens by the introduction of the debugger.

===== Tracing

To get a trace file during the execution of Jamal you can

[source]
----
-Djamal.trace=tracefile.xml
----

on the command line that starts Jamal.
It will specify a trace file, in this case, `tracefile.xml`.
If it is more convenient, you can also specify the trace file using the environment variable:

[source]
----
export JAMAL_TRACE=tracefile.xml
----

The environment variable is taken into account only if the `jamal.trace` system property is not defined.

The trace file will contain all the macro evaluations' inputs and outputs.
Since there can be many Jamal evaluations one after the other, Jamal does not overwrite old trace information.
It appends the new trace information.
Before starting Jamal, you can manually delete the trace file.
Trace files grow large quickly.
If you do not want to trace anymore, do not forget to unset the environment variable typing

[source]
----
unset JAMAL_TRACE
----

to avoid an excessively large trace file growing on your disk.

===== Debugging

To debug a Jamal macro processing you have to start Jamal in debugging mode.
Jamal switches on debugging mode if the system property `jamal.debug` or the environment variable `JAMAL_DEBUG` is defined.
The value of the property or the variable controls which debugger starts and how.

Currently, there are two debuggers implemented:

. web based debugger with UI written in React.js
. a TCP/telnet based debugger.

The detailed technical documentation of the server side of the debuggers is described in the document link:./jamal-debug/README.adoc[debugger readme].
The TCP-based debugger is only for experimental purposes or when the web based debugger is not available.

Here we briefly describe the web-based debugger.
Since the UI can best be described with pictures, especially with moving pictures the documentation is created in screen capture videos.


To start Jamal in debugger mode you can specify

[source]
----
-Djamal.debug=http:8080
----

on the command line that starts Jamal.
It will specify the web based debugger, hence the `http` and the port, in this case `8080`.
If it is more convenient, you can also specify the `http:8080` debug option file using the environment variable:

[source]
----
export JAMAL_DEBUG=http:8080
----

The environment variable is taken into account only if the `jamal.debug` system property is not defined.

If you do not want to debug anymore, do not forget to unset the environment variable typing

[source]
----
unset JAMAL_DEBUG
----

In debug mode Jamal stops twice for each macro evaluation.
Once when it selects the next text without macro from the actual start of the input, or a macro at the start of the input.
Second time when the macro was evaluated, and the text is appended to the output.

If you open your browser after you started Jamal in debug mode and try to open the url `http://localhost:8080` you will get the debugger UI in your browser.
This user interface will let you see the current input, the current output, the defined built-in and user defined macros.
You can let the code run, make one step macro evaluation, go into nested macro evaluation, evaluate text interactuvely in the current evaluation envirionment and so on.


[[SimpleExample]]
=== 1. Simple Example

As a quick sample to have a jump start what Jamal can do:

[source]
----
{@define fruit(color,name,actualSize)=we have an color name of size actualSize}
{fruit/red/apple/20ounce}
{fruit/green/melon/1kg}
----

will be converted by Jamal to the file

[source]
----
we have an red apple of size 20ounce
we have an green melon of size 1kg
----


In this sample, the built-in macro `define` is used to define a so-called user-defined macro `fruit`.
This macro has three arguments named `color`, `name`, and `actualSize`.
When the user-defined macro is in use, the actual values replace these arguments.

Note that the macros open with the `{` character and close with the `}` character in this example.
These are not hardwired in Jamal, and there is not even a suggested default for that.
The embedding application has to define the opening string and the closing string.
For example, the embedding Java::Geci application uses `{%` and `%}` as macro open and macro close strings.
It does it because the `{` and `}` characters frequently appear in the Java source code.
On the other hand, Java code rarely uses the `{%` or `%}` format.
In this documentation, we use the `{` and `}` strings.

However, you have to be aware that this is NOT enforced.
It is not even a recommendation or a convention.
You can specify the macro opening and closing string as the program parameter, and the Jamal source code can also change it.
You can change them using the built-in <<sep,`sep`>> macro (<<sep,see later>>) in the Jamal source.

There is one exception where Jamal uses `{` and `}` as hardwired strings for macro opening and closing.
This exception is implemented in version 1.5.0 and later.
When you import a file into your code, and the imported file starts with the characters `{@`, the import will use `{` and `}`.
This way, you can easily import files from external sources, like a JAR file or via the web.
The package that defines an import file can use the `{` and `}` characters.
Even if your Jamal file uses different macro opening and closing strings, you do not need to change it to `{` and `}` in this particular case.
You may have `[[` and `]]` as opening and closing strings.
In this case, you write `[[@import res:MyResource.jim]]` as an example, and it still will be imported correctly.

The parameters are separated using the first non-space, non-alphanumeric character following the macro's name in the macro use.
Thus, you can write

[source]
----
{fruit/red/apple/20ounce}
{fruit|red|apple|20ounce}
{fruit.red.apple.20ounce}
{fruit :red:apple:20ounce}
----

the output will be the same for each line:

[source]
----
we have an red apple of size 20ounce
we have an red apple of size 20ounce
we have an red apple of size 20ounce
we have an red apple of size 20ounce
----


NOTE: In the last example, we used the `:` character as the separator.
When the name of a macro contains one or more  `:` characters, then the macro is global.
Since this character can also be part of the macro's name, there must be a space before it.

There are also some other rules that make it possible to use a space as separator character.
When a macro has exactly one argument, then the parsing follows special rules.
It is also possible to invoke a macro with more or less number of arguments than are defined using the option `lenient`.
These are advanced topics and are detailed later.

In this case, Jamal will automatically export all the macros defined inside the block.
Note that it only works when the macro definitions happen.
The `block` macro is started using the `#` character.

For more about definition scopes and exporting, read the page about link:documentation/macros/export.adoc[`export`].
On that page, we discuss the evaluation order of the macros in great detail.

[[OtherMacros]]
=== 2. Core Built-in Macros

The core built-in macros are part of the core package.
They contain those essential macros that are vital for the working and use of Jamal.
They are

* link:documentation/macros/try.adoc[`try.adoc`]

* link:documentation/macros/for.adoc[`for.adoc`]

* link:documentation/macros/define.adoc[`define.adoc`]

* link:documentation/macros/end.adoc[`end.adoc`]

* link:documentation/macros/if.adoc[`if.adoc`]

* link:documentation/macros/block.adoc[`block.adoc`]

* link:documentation/macros/begin.adoc[`begin.adoc`]

* link:documentation/macros/script.adoc[`script.adoc`]

* link:documentation/macros/verbatim.adoc[`verbatim.adoc`]

* link:documentation/macros/escape.adoc[`escape.adoc`]

* link:documentation/macros/nullmacro.adoc[`nullmacro.adoc`]

* link:documentation/macros/export.adoc[`export.adoc`]

* link:documentation/macros/options.adoc[`options.adoc`]

* link:documentation/macros/evaluation_order.adoc[`evaluation_order.adoc`]

* link:documentation/macros/macro.adoc[`macro.adoc`]

* link:documentation/macros/debug.adoc[`debug.adoc`]

* link:documentation/macros/import.adoc[`import.adoc`]

* link:documentation/macros/comment.adoc[`comment.adoc`]

* link:documentation/macros/log.adoc[`log.adoc`]

* link:documentation/macros/jshell.adoc[`jshell.adoc`]

* link:documentation/macros/env.adoc[`env.adoc`]

* link:documentation/macros/use.adoc[`use.adoc`]

* link:documentation/macros/sep.adoc[`sep.adoc`]

* link:documentation/macros/ident.adoc[`ident.adoc`]

* link:documentation/macros/catch.adoc[`catch.adoc`]

* link:documentation/macros/include.adoc[`include.adoc`]

* link:documentation/macros/undefine.adoc[`undefine.adoc`]

* link:documentation/macros/defer.adoc[`defer.adoc`]

* link:documentation/macros/require.adoc[`require.adoc`]

* link:documentation/macros/eval.adoc[`eval.adoc`]






[[argsplit]]
=== 3. Standard Built-In Macro Argument Splitting

This section contains the description of the Standard Built-in Macro Argument splitting.
The text describes the syntax used by some of the built-in macros, which do not implement their syntax parsing.
It is essential when you use these macros, for example, the core `if` macro.
The text also mentions some Java internals that may be valuable if you intend to develop your built-in macros.

Built-in macro accesses the input as one single string.
Technically the input parameter of the method `evaluate()` is not a string.
It is an instance of the class `Input` implementing the Java interface `CharSequence`.
That way, we can think of it as a string.
The Java code of the macro is free to interpret this string the way it wants.
Different macros implement their syntax analysis differently.

To manage the input and ease the format analysis and interpretation of the input, there is a utility class named `InputHandler`.
This class defines a method named `getParts()` which does a simple analysis.
It splits the input into an array of strings in a "standard" way.

This method is used, for example, by the implementation of the `if` built-in macro.
I recommend using this method when there is no special requirement for a macro.
Using this method provides a concise way for macro argument separation.
The way it splits the arguments is defined here so that the extension documentation can refer to this section.

The splitting offers three syntax variations:

1. `macroName / a / b / c / ... /x`

2. `macroName   a   b   c   ...  x`

3.  `++macroName `regex` separator a separator b separator ... separator x++`

In the first case the argument separator character is the first special character.
This character can be any unicode character except

* letter or digit,

* back-tick character,

* white space character.

If the first non-white space character is a letter or digit character, then the second syntax is used.
In this case the input is split up along the white space characters.
Multiple adjacent white space characters are counted as one.
The splitting does not create empty parameters.

The third possibility is when the fist non-space character is backtick (`++`++`).
If the first non-whitespace character after the name of the macro id is a backtick, then the parsing expects to be a regular expression till the next backtick.
After the regular expression and after the closing backtick the rest of the input is spit up using the regular expression as separator.

Backtick was selected during the design of the syntax to enclose the regular expression because this character is very rare in Java regular expression.
In case you need one inside the regular expression, then you have to simply double it, and the parsing will single it back.

[[parparsing]]
=== 4. Standard Built-In Parameter/Option Parsing


In addition to the method ``getParts()`` there is another utility that the built-in macros can use.
It is the class `Params`.
The class is a utility to parse some particular part of the whole input of the built-in macro looking for parameters.
This particular part is usually the first line of the input, but it can be the part between `(` and `)` following the macro ID or the whole input.
This utility is used by some built-in core macros.
The core macros use the `[` and `]` characters to enclose the parameters.

[NOTE]
====
The core macros cannot use the `(` and `)` characters, because the syntax of the macro `for` already supported the multi-variable version of it.
Because of that options between `(` and `)` could not be distinguished from the variable list.
To be consistent the macros `block`,`include`, `import`, `eval`, `if`, `macro`, `define`, `log` and `defer` also use the `[` and the `]` characters.
This is also a clear visual separation of core macros from other macros provided by extra modules.
The core macro `debug` uses the whole input, therefore it does not use any of the brackets around the parameters.


====


The documentation of the parameter handling in these macros is not part of this readme.
It can be found in the separate link:documentation/PAROPS.adoc[PAROPS] document.

[[JamalENV]]
=== 5. Jamal Environment Variables

You do not need to configure Jamal.
The environment variables that you may set to modify the behavior of Jamal are documented in this section.
All environment variables start with the prefix "`JAMAL_`".
For every environment variable, there is a corresponding system property.
The name of the system property is the same as the environment variable lower case converted and replacing the `_` to `.` characters.
For example, for the environment variable `JAMAL_CHECKSTATE`, the system property is `jamal.checkstate`.
First, the system property is consulted, and the environment variable has only effect when the system property is not defined.
The following sections describe the individual environment variables.


==== `JAMAL_CONNECT_TIMEOUT`
This variable can define the connection timeout value for the web download in millisecond as unit.
Jamal can download resources when the name of a file starts with the prefix `https://`.

The default value for the timeouts is 5000, meaning five seconds.

The proxy setting can be configured using standard Java system properties.
For more information see the JavaDoc documentation of the class `java.net.HttpURLConnection` in the JDK documentation.

==== `JAMAL_READ_TIMEOUT`
This variable can define the read timeout value for the web download in millisecond as unit.

The default value for the timeouts is 5000, meaning five seconds.

==== `JAMAL_TRACE`
This environment variable defines the name of the trace file.
When a trace file is defined the evaluation and all the partial evaluations are logged to this file during processing.
This file can grow very fast, and it is not purged or deleted by Jamal.

==== `JAMAL_STACK_LIMIT`

sets the recursive call depth in macro evaluation.
Macros may be recursive and in some cases it may create infinite recursive calls in Jamal.
Try a simple Jamal file that contains `{@define a={a}}{a}`.
This will drive Jamal into an infinite recursive call.
During the macro evaluation `{a}` will result `{a}` again and this will be evaluated again and again.
Infinite recursive calls result `StackOverflowError` which should not be caught by any program.
To avoid this Jamal limits the recursive calls to the maximum depth 1000.
This is a reasonable limit.

* Most Jamal sources are not complex, and will not get above this limit recursively.
* At the same time, most Java implementations can handle this dept.

This limit may be too much in your environment.
Jamal may still throw a `StackOverflowError`.
In this case set this to a smaller value.
It may also happen that you deliberately create complex recursive macros.
In that case this limit may be too small.
Set your value to a limit that fits your need.


==== `JAMAL_CHECKSTATE`

This environment variable can switch off macro statefulness checking during macro registration.
It is generally recommended that the macros are stateless to support multi-thread evaluation when a single JVM runs multiple Jamal processors in one or more threads.
If a macro has to have a state, it must be annotated using the annotation `Macro.Stateful`.
The statelessness or annotation is checked during macro registering since Jamal version 1.8.0.
You can switch off the functionality setting this environment variable to `false`.
It may be needed if you want to use an older, prior 1.8.0 library or a library that does not follow this rule.

==== `JAMAL_DEBUG`

This environment variable can switch on debugging of Jamal.
To use the debugger, this variable has to set to a value, which is recognized by a debugger on the classpath.
The web-based debugger recognizes the `http:port` format variables.
Set this variable to `http:8080`, put the `jamal-debug` module on the classpath and after starting Jamal processing open your browser at `http://localhost:8080`.
The debugger and the use of it is detailed in a separate section.

==== `JAMAL_INCLUDE_DEPTH`

This variable can set the maximum number of files include nesting.
The default value is 100.

==== `JAMAL_HTTPS_CACHE`
This variable can be set to point to a directory for cache files.
When Jamal downloads web resources it stores them in a cache directory is the directory exists.
Jamal creates subdirectories under the cache directory, but the cache directory itself has to be created manually.

The default location for the cache files is `~/.jamal/cache/`.

==== `JAMAL_DEV_PATH`
This environment variable can define replacements for files.

The aim of this feature is to use a local file during development, and still refer to it using the `https://` URL, which will be the production URL.
You want to run tests without pushing the file to a repository, but at the same time you do not want your code to refer to a dev location to be changed before releasing.11

Only absolute file names can be replaced.

For example, you include the file `https://raw.githubusercontent.com/central7/pom/1/pom.jim` in your Jamal file.
You want to replace it with a local file `~/projects/jamal/pom.jim`.
In that case you should set the environment variable

[source]
----
export JAMAL_DEV_PATH=\|https://raw.githubusercontent.com/central7/pom/main/pom.jim?SNAPSHOT=~/github/jamal/pom.jim
----

The environment value is a list of `=` separated pairs.
The list is parsed using the standard `InputHandler.getParts(Input)` method.
This is the reason why the first character in the example is the separator `|`

An alternative use is to specify an existing text file in this variable.
In that case the file will be read by Jamal, and the individual lines will be interpreted as `key=value` pairs.
Comment lines starting with `#` and empty lines are ignored.


==== `JAMAL_OPTIONS`

This environment variable can define options for the Jamal processor.
The value of the variable is interpreted as a multi-part input.
The list is parsed using the standard `InputHandler.getParts(Input)` method.
If you just have one option then you can define that with the name.
If there are multiple options then you have to select a non-alphanumeric separator character and present it in front of the list.

NOTE: that the usual `|` character has a special meaning for the bash, and therefore you may need escaping.
Also note that using `:` as a separator character may work, but it may be misleading as it can also be part of an option name.

The options are set on the top level, there is no need to use a `:` prefix.
To set an option to `false`, you can use the `~` character, but please do not.
Every option default value is `false` when not set.

The typical use of this possibility is to set the option `failfast`.
This option alters the error processing, and it is more "bound" to the execution than to the document.
It may be a better option to include it in an environment variable, or system property than in the document itself.
Both approaches work.




[[httpsres]]
=== 6. Resource Files and Web Resources

When the macros `import` or `include` reference a file with a name that starts with

* `res:`,
* `https:`,
* `maven:`,
* `jar:`, or
* __some other prefix__ `:`

then these files are treated in a special way.
When a file name starts with '__prefix__`:`' it is passed to a special handler.
The handlers are loaded automatically via the ServiceLoader mechanism.
It means that anyone can extend Jamal implementing new handlers reading files from different sources.

In any other case the files are loaded from the local disk.

The following two subsections detail the mechanism for the three implemented handlers.

NOTE: The `res:` and `https` handlers are implemented in the `jamal-tools` module.
These handlers can be used without any extra dependency.
The `maven:` handler is implemented in the `jamal-maven-input` module.
This module has an external dependency.
Implementing this handler in a separate module it is easier to separate Jamal from external modules.
As a general rule Jamal is developed minimizing the external dependencies for the core modules.
Modules, macros needing external libraries are developed in separate modules.
If there is any security, licensing or other issue with the external library, then the module can be removed from the installation without affecting the core functionality of Jamal.
Security, licensing and other issues are addressed in development.
Removing the modules is a workaround and temporary solution.

==== Java Resource Files

When the file name starts with the characters `res:` it is a Java resource file.
It means that the file is in a JAR file among the classes.
The JAR file has to be on the classpath.
When Jamal is started from the command line, then the JAR file has to be added to the classpath.
The classpath is usually after the `-cp` or `-classpath` argument of the Java command line.
If Jamal is started as a Maven plugin, then the configuration in the `pom.xml` file should include the dependency.
For example, to add the pomlib library JAR to the classpath you can use the following fragment in your `pom.xml`:

[source,xml]
----
<plugin>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-maven-plugin</artifactId>
    <version>2.3.1-SNAPSHOT</version>
    <executions>
        <execution>
            <id>execution</id>
            <phase>clean</phase>
            <goals>
                <goal>jamal</goal>
            </goals>
            <configuration>
                ... configuration tags ...
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>com.javax0.jamal</groupId>
            <artifactId>jamal-pomlib</artifactId>
            <version>1.0.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
</plugin>
----

NOTE: The module `jamal-pomlib` is here as an example, although it was discontinued and is not part of the current Jamal library structure.

===== Loading Resources from `maven:load` loaded libraries

Starting with version 2.0.0, it is possible to load macros from Maven artifacts using the macro `maven:load`.
The resources in these artifacts are not on the classpath.
In this case, the application uses different classloaders to load the macro classes that are usable by default and those loaded with the `maven:load` macro.
Jamal uses the application class loader to load resources using the `res:` prefix unless otherwise instructed (see below).
This classloader does not see the dynamically loaded classes and resources.

To load a resource from a dynamically loaded library, the `res:` prefix has to be followed by the name of a macro enclosed between `pass:[`]` backtick characters before the resource name.
That way, the resource loading will use the class loader, which loaded the macro and will eventually find the resource in the dynamically loaded library.

==== Web Resources

Web resources can be downloaded using the `https:` prefix.
The only protocol supported is `https`.
Jamal does not download any resource using the unencrypted `HTTP` protocol.

It is possible to cache the downloaded files.
The environment variable `JAMAL_HTTPS_CACHE` can define a directory to store the web resources.
In case the environment variable is not defined, then the default value `~/.jamal/cache/` will be used.
If the cache directory exists, Jamal will store the downloaded files in it.
Jamal will create the subdirectories if needed, but Jamal will never create the cache directory itself.
If you do not want to use the caching, then do not create the cache directory.

Jamal will not cache a downloaded files that has `SNAPSHOT` in the URL (all capital letters).
There is no cache eviction or expiration by default.
You can find the files in the cache directory in subdirectories.
You can also find the corresponding property files there that contain information about the caching.
These properties files contain information about when a file was stored in the cache and also when it was last time read.
It is also possible to define Time To Live (TTL) for the cache items.

Ttl value can be defined with the `ttl` property key.
The value can be a raw number expressing the ttl in seconds or a string with time unit(s).
The units are:

* `y` for year(s) (365 days)

* `M` for month(s) (31 days)

* `w` for week(s) (7 days)

* `d` for day(s) (24 hours)

* `h` for hour(s) (60 minutes)

* `m` for minute(s) (60 seconds)

* `s` for second(s)

If you use multiple time units, then the value is the sum of the time units.
The units should be used in `Y`, `M`, `w`, `d`, `h`, `m`, `s` order.
You can omit the units that have zero value.
You can use any number in front of a unit, you are not limited with the natural amount of time units.
For example, you can say `1d25h` for 1 day and 25 hours, which is exactly the same as `2d1h`

Examples:

* `13y` means 13 years

* `13y1m3h` means 13 years, 1 month and 3 hours

The property values, `ttl` or other values, are read from the property file and are inherited from `.properties` files.
These files are not created by Jamal, but you are free to create them with different keys and values.
The `.properties` files can be created in the different cache directories up to the root directory of the properties.
When a key is defined in multiple `.properties` files, then the value closer to the properties file of the cached item is used.
If the key is defined in the properties file of the cached item, then the value is used.
This way you can define the TTL for a specific cache item, a group of items and for the whole cache.

The connection to the web can be configured if needed.
The environment variables that can be used are the followings:

* `JAMAL_CONNECT_TIMEOUT`, and

* `JAMAL_READ_TIMEOUT`

can define two timeout values for the web download in millisecond as unit.

The default value for the timeouts is 5000, meaning five seconds.

The proxy setting can be configured using standard Java system properties.
For more information see the JavaDoc documentation of the class `java.net.HttpURLConnection` in the JDK documentation.

==== Maven resources

When the name of the file stats with the characters `maven:`, then Jamal tries to find the file in the Maven repository.
You can use file names like

[source]
----
{@include [verbatim] maven:com.javax0.jamal:jamal-groovy:1.12.5:compile:version.properties}
----


which will result

[source]
----
version=1.12.5
----


For more information read the link:jamal-maven-input/README.adoc[documentation] of the module implementing the `maven:` prefix.

[[error_messages]]
=== 7. Error Messages

When there is a processing error, then Jamal throws a Java exception.
The message of the exception contains at the end the location of the error.
Sometimes it is not simple to identify the location due to the string replacement nature of Jamal processing.
To help locate the error as precise as possible, the location is given as a series as triplets.
Each triplet contains a file name, a line number and a column number.
The location is given in the following format:

    file/line:column

When a file includes or imports another file, then the location of the file is given in the error message along with the location from where the file is included or imported.
The format in this case is

    file/line:column <<< file/line:column

If the include/import hierarchy is deeper, then the location is also given in several levels.
In some cases the hierarchy is created in the error message inside a single file to help locating the error.

[[snippet]]
=== 8. Snippet Handling

Snippets are text fragments from the source code or from other text files that are to be included in the documentation as samples.
Jamal Snippet handling macros can automate the copying of such lines, but they can do more.
These macros can trim, line number, transform the source text before inserting into the output document.

The snippet handling macros are documented in the link:jamal-snippet/README.adoc[Snipped module readme].
These macros include also date handling, run-time checking of existence of referenced files, directores, classes, methods and so on.

[[Groovy]]
=== 9. Groovy Integration


The Groovy language integration lets you include Groovy code fragments into your document.
These scripts are executed during the file processing, and can programmatically calculate the macro outputs.

The integration and how to use the module macros are described in the link:jamal-groovy/README.adoc[Groovy readme].


[[Ruby]]
=== 10. Ruby Integration

The Ruby language integration lets you include Ruby code fragments into your document.
These scripts are executed during the file processing, and can programmatically calculate the macro outputs.

The integration and how to use the module macros are described in the link:jamal-ruby/README.adoc[Ruby readme].


[[JSON]]
=== 11. JSON Integration

The JSON module can be used to simplify the maintenance of JSON files using macros and splitting up the JSON files into smaller chunks.
The documentation of the module is link:jamal-json/README.adoc[JSON readme]

[[Yaml]]
=== 12. Yaml Integration

The Yaml module can be used to simplify the maintenance of Yaml files using macros and splitting up the Yaml files into smaller chunks.
The documentation of the module is link:jamal-yaml/README.adoc[Yaml readme]

[[IO]]
=== 13. IO Module

The Io module can be used to write text into separate files during the processing of a Jamal input file.
The documentation of the module is link:jamal-io/README.adoc[Io readme]

[[JamalAPI]]
=== 14. Jamal API

Embedding Jamal into an application is straightforward.
You need the Jamal libraries on your classpath.
If you use Maven, you can simply have

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-engine</artifactId>
    <version>2.3.1-SNAPSHOT</version>
</dependency>
----

in your pom file.

The library `jamal-engine` transitively depends on the other libraries that are needed (`jamal-core`, `jamal-api` and `jamal-tools`).

You also have to specify that you use the modules (Java 9 and later) if your code uses modules.

[source]
----
module jamal.maven {
requires jamal.api;
requires jamal.tools;
requires jamal.engine;
}
----

You can instantiate a `Processor` object to process the input.

[source,java]
----
import javax0.jamal.engine.Processor;

var processor=new Processor(macroOpen,macroClose);
var result=processor.process(input);
----

The `macroOpen` and `macroClose` parameters are `String` values.
The parameter `input` to the method `process()` has to be an object that implements the `javax0.jamal.api.Input` interface.
The easiest way to do that is to use the readily available class `javax0.jamal.tools.Input`.

You can see an example to create an `Input` from an existing file in the `jamal-maven-plugin` module:

[source,java]
----
result = processor.process(
        new javax0.jamal.tools.Input(
                Files.readString(inputPath, StandardCharsets.UTF_8),
                new Position(inputPath.toString(), 1)));
----

An `Input` holds the content the processor has to process.
It also has a reference file name used to resolve the absolute names of the included and imported files.
It also keeps track of the line number, and the column of the actual character as the macro evaluation progresses.
A `new Position(s,1)` creates a new position that identifies the file by the name's` and the line number 1.

When a new processor is instantiated, it uses the `ServiceLoader` mechanism to find all the built-in macros that are on the classpath.
If your application has special macros implemented in Java, then you can just put the library on the `modulepath`.
If the classes are defined in the `provides` directive of the module, then Jamal will find and load them automatically.

It is also possible to define user-defined and built-in macros via API.
To do that you need access to the `MacroRegister` object that the `Processor` object has.
To get that you can invoke the method `getRegister()` on the processor object:

[source]
----
var register=processor.getRegister();
----

The register has API to define macros and user-defined macros.
For further information, see the API JavaDoc documentation.

There is a very simple API class that makes it possible to use Jamal as a templating engine.
The utility class `javax0.jamal.Format` has the method
`public static String format(String content, Map<String, String> predefinedMacros)`
that can format the `content` string using the entries of the `predefinedMacros` as user-defined macros.
These macros eventually cannot have arguments.
This is a simplified interface to access the functionality of Jamal.

[[javadoc]]
=== 15. JavaDoc and API

The current and past versions of the JavaDoc can be read online at the address:


* https://javadoc.io/doc/com.javax0.jamal/jamal-api/


* https://javadoc.io/doc/com.javax0.jamal/jamal-assertions/


* https://javadoc.io/doc/com.javax0.jamal/jamal-cmd/


* https://javadoc.io/doc/com.javax0.jamal/jamal-core/


* https://javadoc.io/doc/com.javax0.jamal/jamal-debug/


* https://javadoc.io/doc/com.javax0.jamal/jamal-doclet/


* https://javadoc.io/doc/com.javax0.jamal/jamal-engine/


* https://javadoc.io/doc/com.javax0.jamal/jamal-extensions/


* https://javadoc.io/doc/com.javax0.jamal/jamal-groovy/


* https://javadoc.io/doc/com.javax0.jamal/jamal-io/


* https://javadoc.io/doc/com.javax0.jamal/jamal-jamal/


* https://javadoc.io/doc/com.javax0.jamal/jamal-java/


* https://javadoc.io/doc/com.javax0.jamal/jamal-maven-input/


* https://javadoc.io/doc/com.javax0.jamal/jamal-markdown/


* https://javadoc.io/doc/com.javax0.jamal/jamal-maven-extension/


* https://javadoc.io/doc/com.javax0.jamal/jamal-maven-plugin/


* https://javadoc.io/doc/com.javax0.jamal/jamal-plantuml/


* https://javadoc.io/doc/com.javax0.jamal/jamal-ruby/


* https://javadoc.io/doc/com.javax0.jamal/jamal-scriptbasic/


* https://javadoc.io/doc/com.javax0.jamal/jamal-snippet/


* https://javadoc.io/doc/com.javax0.jamal/jamal-test/


* https://javadoc.io/doc/com.javax0.jamal/jamal-testsupport/


* https://javadoc.io/doc/com.javax0.jamal/jamal-tools/


* https://javadoc.io/doc/com.javax0.jamal/jamal-word/


* https://javadoc.io/doc/com.javax0.jamal/jamal-yaml/


* https://javadoc.io/doc/com.javax0.jamal/jamal-json/



In addition to the low level API, there are facades that help the use of Jamal for special purposes.
One of them is implemented by the class `javax0.jamal.Format`.
The other one is in the class `javax0.jamal.DocumentConverter`.

The class `Format` is a facade that provides a simplified interface to the functionality of the Jamal.
The method `name()` has two arguments.
The first is the content to be formatted.
The second is a map of predefined macros.
These macros are all parameterless macros.
It is not possible to define parameters using this interface.
Although the content string can contain any Jamal macros.

This interface also invokes the Jamal processor with `{{` and `}}` as the macro open and close characters.


The other class, `DocumentConverter` supports document converting.
This is usually done during the build process in the unit test phase.
The practice is to create one or more unit tests converting the project `.jam` files.

The method `convert(file)` converts the file given as argument.
The resulting file will be created in the same directory as the original file with the `.jam` extra extension chopped off.
For example, if you convert `README.adoc.jam`, then the resulting file will be `README.adoc`.

The other method `convertAll(file)` converts many files.
It takes two arguments, both are list of file name endings.
The first is the file endings (extensions) to include, the second one is the file endings (extensions) to exclude.
The two static methods `include()` and `exclude()` can be used to create these arguments.


[[documentmaintenance]]
=== 16. Maintenance of this document

The source of this document is `README.adoc.jam`.
The Jamal conversion uses the snippet macros and some core built-in macros.
The conversion is part of the execution of the tests.
The code samples are automatically executed using this process, and the sample output is automatically inserted into the document.
