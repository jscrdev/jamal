== Standard Built-In Parameter Parsing
{%@define methodFormat=`$name()`%}\

Even though built-in macros are free to parse their input any way they want, there are support classes that ease this task.
The advantages of using these classes are twofold.

. These classes are thoroughly tested, documented, and easy to use, saving development time and effort.

. The macros are more coherent and easier to understand for the users when they follow similar patterns.

[NOTE]
====
This document describes the format and use of the parameters of the built-in macros using these supporting classes.
====

=== Introduction

Parameters are name-value pairs that modify the behavior of a macro.
For example, the line

[source]
----
{@include [verbatim lines=1..13] otherContent.txt}
----

will instruct Jamal to include the file verbatim and only the lines from 1 to 13.

The parameters are between the `[` and `]` characters.
They have to form `name=value` pairs separated by spaces.

The enclosing characters for the parameters are not hard-wired.
Each macro can declare the characters it uses to enclose the parameters.
It is customary to use `[` and `]` for the core macros and `(` and `)` for the macros in other packages.

NOTE: The use of the `[` and `]` characters in case of the core macros was a decision late in the development process.
The macro `for` was the first one to support parameters, and it already used the `(` and `)` characters to enclose the parameters.
To keep backward compatibility, the decision was made: the core macros will use `[` and `]`.
There is nothing to stop a non-core macro from using these characters, but it is not recommended.

There are macros which do not need any content other than the parameters.
In this case, the parameters are the whole input and are not enclosed in any characters.
Some macros use line oriented input, and they assume an empty first line.
The first line is used for parameters in that case, also not needing any enclosing characters.

The macros can have mandatory and optional parameters.
Parameters have types and can have default values.
Specifying a parameter not handled by the macro is an error.

The macro Java implementation declares the parameter names, types, and optionally default value.
The helper tool automatically parses the input.
The macro Java code gets the values for the parameters parsed and converted.

Parameters can be

* integer numbers,
* strings,
* boolean values (always have a default value Ë›false`), and
* regular expression patterns,
* lists.

Some parameters may have multiple values.
Enumerated parameters can be emulated using boolean parameters. (Discussed later.)

The Java code can define a name and also aliases for the same parameter.
The names and aliases can be used interchangeably, though the Java code can query the actual name used.
The use of this feature is acceptable in some special cases only, like emulating enumerated parameters.

Names and aliases are case-sensitive.

The parameter name is also the name of the user-defined macro that can be used to define the value of the parameter.
Aliases are not considered as macro names when searching for values.

TIP: Let's say that a parameter has the name `globalFormat` an the alias `format`.
In that case the user defined macro `globalFormat` can be used to define the value of the parameter.
The parameter name `globalFormat` can also be used as a parameter name on the input and so can the alias `format`.
However, even if there is a macro defined and named `format` it will not be used to define the value of the parameter.
Aliases work only in the input of the macro.

The Java code may define the name to be `null`.
In this case, only the aliases are defined without name.
It means that no user defined macro can define the value for the parameter.

NOTE: The parameters start and end with an opening and closing character.
The macros have opening and closing strings.
Macro parameter parsing uses single characters.

As we have seen, the `include` macro with the parameters

[source]
----
{@include [verbatim lines=1..13] otherContent.txt}
----

uses the `[` and `]` characters.

The built-in core macros use these separator characters.
Currently {%@listDir (
              grep="(?:Scan).using\\(processor\\).from\\(this\\)" pattern=".*\\.java$"
              countOnly
              )
../jamal-core/src/main/java/javax0/jamal/builtins%} built-in core macros have parameters.

The class `{%@java:class javax0.jamal.tools.Params%}` provides the tools to ease parameter parsing.

=== Parameter Sources

When macros need parameters using the support classes, they look at different sources for the values.
First, they look at the macro's input and try to find the parameters.
The parameters are specified in the format

[source,text]
----
name1=value1 name2=value2 ... nameN=valueN
----

The names are the parameter names that the macro may use.

The macro first passes the input to the parsing method.
When a parameter is not defined, the algorithm tries to look up a user-defined macro with the name as the parameter.
If you set `{@define margin=2}` somewhere in your Jamal source, this value will be used by every `trimLine` following it.
If the value is not defined as a parameter or a user-defined macro, then the built-in macros can use default values.

NOTE: The macro `default` usually steps into the place of an undefined macro.
Not in this case.
It is also an error if the macro used as the configuration has parameters unless the option `{@options lenient}` is specified.

The parameters have types.

* In the case of boolean parameters, the values `false`, `0`, or `no` are treated as false.
Everything else will result `true`.
The usual way to use boolean parameters is to specify the parameter name only.
If a required boolean parameter is not present as a parameter, then the option of the same name is taken into account.
The option is the one that you can set using the macro `{@options ...}`.
For example, you can specify `{@options trimVertical}` if you want all uses of the macro `trimLine` to trim vertically.
User-defined macros for a boolean parameter are NOT used.
All boolean options are `false` by default; hence there are no mandatory boolean parameters.
Undefined boolean parameters are `false`.

* Parameters can be strings and integers.
These can be defined in a parameter or as the value of a macro, as described above.
A parameter is string or integer when it is declared like that in the Java source.
You can freely enclose integer parameters in quotes and specify a string without quotes.
Note, however, that in the latter case you cannot use some special characters in the string, like spaces or `=`.

* Some parameters can have more than one value.
The parameter's `name` can appear more than once with multiple values assigned to it.
In this case, the name or an alias appears multiple times a value assigned.
The names and the aliases can be mixed arbitrarily.

Macros may decide whether to define any default value for a parameter.
If not, the macro will error if the parameter is not defined and there is no user-defined macro.

The parameter names can have aliases.
These are used solely inside the macro as parameters.
Alias names do not play a role as user-defined macros.
In other words, the "main" name of the parameter can also be a macro; aliases cannot.

The core macro uses `$forsep` as a parameter and has an alias `separator`.
If neither is specified in the macro, only the user-defined macro `$forsep` is consulted.
If there is a `{@define separator=;}` in the code, it will not alter the `for` macro execution.
In the parameter list, however, the names and the aliases are interchangeable.

Macros can define parameters using only aliases.
Technically they specify `null` as the name and give meaningful strings only for one or more aliases.
In that case, there is no way to define a global value for the parameter as a macro.

Aliases are specific to the macro.
Different macros may use the same parameter name for different purposes, providing different or the same aliases.
It is up to the macro implementation what parameter names and aliases they use.
However, the parameter names and the aliases are unique in a single macro implementation.

=== Details

In the parameter definition

[source,text]
----
name1=value1 name2=value2 ... nameN=valueN
----

the `value1, value2, ..., valueN` values are either _numeric_, _boolean_ or _string_ values.
The type depends on what the macro awaits for the specific parameter.

You can enclose the values between `"`, `"""` or without any delimiter.
`"..."` is a typical string representation.
Using the `"` is optional if there is no space or a particular escape sequence in the value.
For example, `margin=1` is just as good as `margin="1"`.
On the other hand, `name=Peter Verhas` is not valid.
It has to be represented as `name="Peter Verhas"` because it contains a space.

A string starting and ending with a `"` character must not contain a new-line character.
If you need multi-line strings, use the `\n` characters or a triple-quoted multi-line string.
A multi-line string starts and ends with `"""`, three quote characters.

Some macros use only the first line for parameters.
Even in this case, the new-line character inside a triple-quoted string is part of the value and does not stop the parsing.
The parsing stops only at the first new-line character, which is not part of any value and not escaped.

If there are many parameters, and the first line becomes too long, then the `\` character escapes the new line.
Subsequent lines can also escape the new-line character using the `\` character.
It makes the parser skip the new line and go on parsing on the following line.

Let's assume that we have a macro `someMacro` and the Java class `SomeMacro` declares the parameters to be on the first line of the input.

[source,text]
----
{@someMacro header="""
This is the header
text and it is
multi-line
""" paging=true skip="A" skip="DD" skip="3.145" \
comment="this is still a parameter because of the \\ at the end of the previous line"
this is the input the macro will use for its result; everything else until here are parameters
}
----

When the macro declares that the parameters are on the first line or until the end of the input you can still optionally use `(` and `)` to enclose the parameters.

When the macro asks the parser object to parse the input, it also specifies the parameter names it can handle.
An error will occur if there is any parameter the macro does not handle.

The macro also specifies the type of the parameter.
If Jamal cannot convert the parameter value to the required type, an error will occur.

* Numeric parameters are integers. You can enclose them between `"` or `"""`.

* Boolean parameters are `true` if they are present without any value.
Using the string values `false`, `0`, or `no` will mean a `false` value.
They are `false` if they are not present as a parameter, and the name (not an alias) is also `false` as an option.
A name is `false` as an option if the macro `{@options name}` was not invoked in the current or higher scope or if you invoked the option in the form `{@options ~name}`.
You can set a boolean parameter to `true` by mentioning the name without `=` and any value.
Any value other than that listed for `false` will mean a `true` value.
We recommend using only the name without any value assigned to it.

As you can see in the example, some parameters can have multiple values.
An error will occur if multiple parameters are defined, but the macro accepts only one.
If only one value is defined, but the macro needs a list, it will get a one-element list.
You cannot specify multiple values for such parameters using user-defined macros.
Jamal will not add the global or locally defined user macro to the parameter list if the parameter is specified at least once on the input.
If there are parameters, those values are used; the macro values are ignored.

Single-line and multi-line strings have similar syntax as Java strings.
You can use the same escape sequences.

=== Examples

In this chapter, we list some syntax examples and the use of the parameters.
These examples come from the unit test file

    {%@file ../jamal-test/src/test/java/javax0/jamal/test/tools/params/TestParams.java%}

The display of each example contains a definition line, an _INPUT_ part, and a _RESULT_ part.
The "INPUT" part shows the code that defines the values of the parameters.
It may also contain at the start some `options` or `define` macro in case some parameters get value from this source.
The "RESULT" part shows the calculated value of every parameter.

The definition line contains the parameters' names comma separated.
Each parameter has at least one name.
In case the parameter has an alias that can be used as a parameter name instead of the original name, it is given after a `|` character.
The parameter type is either `I` integer, `S` string, `B` boolean, or `L` list.
The last part following the last `:` is the default value, if there is any.

The test parses this definition string and calls the appropriate `orElse()`, `orElseInt()`, `asString()` and so on methods, which define the type of the parameter.

The RESULT part shows the parameters with the values as `key=value`.
When the returned value is a string, the result is enclosed between quotes.
When the value has some other type, it is shown like a casting operation `(type)` in front of the value.

{%@define section($X)=
==== $X%}

{%@snip:collect from="../jamal-test/src/test/java/javax0/jamal/test/tools/params/TestParams.java"%}
{%@define example($XXX)=
{%#replaceLines replace=/<p>//^\s*\*\s*//
{%@snip head_$XXX%}%}
[source,text]
----
{%#replaceLines replace="/input:/----\nINPUT\n\n[source,text]\n----\n/result:/----\n\nRESULT\n\n[source,text]\n----\n/<p>//"
{%#replaceLines replace=/^\s*"//(\\n)?"\s?\+?$//\\"/"/\\\\/\\/
{%@snip $XXX%}%}
----
%}
{%#replaceLines replace=/<p>//^\s*\*\s*//
{%@snip doc_$XXX%}%}%}
{%@comment
Get the snippets that are in the file `TestParams.java`.
Get only those that do not contain a `_` character in the name.
The snippets are named `header_testMethodName`, `testMethodName`, and `doc_testMethodName` for the three parts for each example.

We use # in the 'for' loop because we want the snip:list to be evaluated to get the snippet ids.
After the iteration, we want to evaluate the 'example' macros, protected by a ` back-tick.
After Jamal evaluated them, we evaluate the result as the snippets may also use macros, like 'section'.
%}
{%!!#for $snippet in ({%@snip:list file="TestParams.java" name="^[^_]+$"%})=
{%`example $snippet%}
%}
