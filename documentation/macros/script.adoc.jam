{%@import macrodoc.jim%}
{%MACRO name="script" since=1.0.0%}

The macro `script` defines a user-defined macro interpreted as a script.
The syntax of the command is

{%sample/
{@script/scripttype id(parameters)=body}
%}

If `script` is followed by `/` character, then the next identifier is the type of the script.
If this is missing the default, `JShell` is assumed.
You can use any scripting language that implements the Java scripting API and the interpreter is available on the classpath.

The parameters are handled differently from the parameters of the user-defined macros defined using the `define` built-in macro.
In that case, the parameter strings are replaced by the actual value strings during evaluation.
In this case, the parameters are used as global variable names.
Using these names, the actual values are injected into the context of the script before evaluation.

This also implies that you do not have the total freedom of parameter names.
For `define` we can use any string as a parameter id so long as long it contains no `,` and no `)`.
In this case, you should care about the syntax of the scripting language used.
The parameter names have to be valid identifiers in the scripting language as they are used as such.

The value injection converts the actual value of the parameter to script values.
Because the parameters are injected into global variables Jamal performs some conversions.
Without this, all the scripts that use some integer or floating-point calculation were supposed to convert them first from the string.

Therefore, Jamal tries to convert the actual parameters.

* First it tries treating it as an integer.
If it succeeds, then the global variable having the name as the parameter will hold an integer value.

* If the conversion to an integer does not work, then it tries the same with double.

* If that is also not feasible, then it will check if the actual value is lower case `true` or `false`.
In this case the global variable of the script will be a `Boolean` value.

* In any other case, the global variable will get the actual value as a string assigned to it.

The actual scripting implementation may not have `Integer`, `Double` or `Boolean` type but there will be some script type corresponding.

The following sample shows a simple script that implements a looping construct using JavaScript.
The source Jamal file:

{%@comment  the four braces in the code are replaced with a single one before the JShell is executed%}\
{%sample/
{@script for(loopvar,start,end,text)=
var c = "";
for( var i = start ; i <= end ; i++ ){
c = c + text.replaceAll(loopvar, ""+i);
}
System.out.print(c);
}
{for%xxx%1%3%xxx. iterated
}
%}

The output generated by the Jamal preprocessor:

{%safeoutput%}

Note that the script code itself contains the macro opening and closing strings.
This does not do any harm so long as long these are in pairs.
It is a better practice to change the separator characters to something that cannot appear in the body of the script macro.

Starting with version 1.3.0, Jamal supports the JShell built-in scripting engine.
You can define `JShell` as a script type.
In this case, the content will be passed to the Java built-in JShell engine.
When the script is invoked, the result of the macro will be the string printed by the JShell script.
If this is empty, the value of the last Java shell snippet will be used.
The argument names have to be valid Java identifiers.
When the script is invoked they will be defined as `String`, `long`, `double` or `boolean` variables.
They will get the actual values of the parameters.
The type depends on the actual value.
If the value string can be interpreted as a `long`, then it will be converted to `long`.
If the string is not a long, but can be converted to `double`, then the variable will be `double`.
If the string is either `true` or `false` case insensitive, then the variable will be `boolean`.
In any other case the variable will be declared as `String`.

In short, the arguments to a `script` macro will be converted to the following types in this order, whichever first succeeds:

* `long`
* `double`
* `boolean`
* `String`


For more information and details, see the macro {%$ JShell%}.
