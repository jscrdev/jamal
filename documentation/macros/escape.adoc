
= `escape`

since version `1.5.4`


== Syntax

  {@escape `SEP`...`SEP`}
  {@escape* `SEP`...`SEP`}

Escape the content of the macro from evaluation even if it contains macro opening and closing strings.
The `++`SEP`++` is any string that does not appear in the content of the macro.

== History

- since 1.9.1 (`escape*`)

== Description

This macro is parsed specially and overrides the macro parsing.
Using `escpe` the macro nesting can be avoided.

The part `SEP` between the back-tick characters can be any string, which does not appear inside the escaped string.
This string along with the back-ticks has to be repeated at the end of the macro before the macro end string.

The result of the macro is the escaped string without any modification.
The macro itself is very simple.
The speciality of the macro is that it overrides  the text parsing that locates the end of the macro.

.Jamal source
[source]
----
{@escape `a`{`a`}
----

will result

.output
[source]
----
{
----


[NOTE]
====
This macro originally was intended to be used by Jamal itself when evaluating a user defined macro, which was defined using different macro opening and closing strings than the actual one.
In this case the macro opening and closing strings, which were in effect at the time of the macro definition are replaced with the current one.
That way the macros defined inside the macros will be evaluated even though the macro opening and closing strings have changed.

At the same time the current macro opening and closing strings had no special effect by the time of the macro definition.
If there is any current macro opening and closing string in the definition of the macro, then they should not play a special role.
They get protected using the `escape` macro automatically.
====

There is another way to escape content from macro evaluation.
You can write a `*` right after the `escape` keyword, as

.Jamal source
[source]
----
{@escape* `a`{`a`}
----

In this case, the escape not only escapes the macro opening and any other otherwise processable content but also results in the protecting shell around the escaped string.
The result in this case will be

[source,text]
----
{@escape*`a`{`a`}
----

[NOTE]
====
You will never see in your output the `escape*` macro.
It is eliminated after the whole file was processed by Jamal invoking a so-called closer.
The closer object is automatically created and registered by Jamal when the `escape*` macro is used.

You can use the closer functionality of Jamal via the link:defer[`defer`] macro.
====

This macro comes in handy when you want to protect something from evaluation that should never be interpreted as a macro text.
For example, you can have a Maven property in a `pom.jam` file, like `${project.build.sourceDirectory}`.
You can redefine at the start of the file the macro open and macro close strings, but it may be simpler to protect the one or few special strings.
A normal escape, without the `\*` after the keyword hides the content from evaluation only once.
When the `*` character is used the content will be protected even when it is deep inside macros and target for many different evaluations.
It should only be eliminated at the very end of the processing on the top level, which is done automatically.

The macro `escape*` will liberate the content.
The liberation will happen after the whole content was already processed in a so called "closer".
Built-in macros implemented in Java have the possibility to register an object to be executed after the processing of the whole content.
Such an object is a closer, and it can be used to close resources that were open by the macro during processing.
During the execution of this closer the code can access and modify the final result.

The macro `escape*` registers a closer that will invoke the Jamal processing again for the output with a flag that tells every `escape*` macro to release its content.

In some cases it may happen that you want the `escape*` closer run before some other closers, but the `escape*` happens later than the register of the other closer.

The different closers are invoked in the order they were registered.
You may use a macro link:defer[`defer`], which also creates a closer.
The use of the macro link:defer[`defer`] precedes the first evaluation of an `escape*` macro.
In this case the closer registered by link:defer[`defer`] would be evaluated before the `escape*` closer.
If you want the `escape*` closer to run first, you have to use the macro `escape*` before link:defer[`defer`].
The simplest form is

[source]
----
{@escape*````}
----

It essentially escapes an empty string delimited by two backtick delimited empty strings.
(Hence, the four back-ticks.)
After the content liberation the result will be an empty string, thus there is no harm using this before any link:defer[`defer`] macro.

The closer registered by `escape*` is simple.
It simply evaluates the result setting a flag that tells `escape*` that this time it should ignore the `\*` character.
