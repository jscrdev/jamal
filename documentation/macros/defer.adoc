
= `defer`

since version `1.10.0`


The macro `defer` stores its input, and evaluates it when the processing of the input file is finished.
It can be used to execute some macros at the end of the execution for the side effects or to modify the final output.

Using this macro is complex and rarely used.
It is an advanced technique.

At the place of the macro the value of the macro is an empty string.
The result of the evaluation is ignored.
This is the only reasonable action as the deferred evaluation happens after the whole input was processed and the final output is already finished.
There is, however, a possibility for the content of the macro to read the final result and also to modify it.

When the input of the macro is executed the global macro `$input` contains the output of the processing.
The naming may be strange at first, but consider that this string is the input for the deferred macro evaluation.

image::input_output.svg[]

If this evaluation defines the global macro `$output` the value of the macro will be used instead of the original output.

The name of the input and output macros can be changed using options.
The options

- `$input` with the aliases `input`, and `inputName` can specify the name of the input macro.
- `$output` with the aliases `output`, and `outputName` can specify the name of the output macro.

As usually the option name can be defined as a macro, like `{@define $input=$INPUT}`, the aliases can only be used as macro options, like

.Jamal source
[source]
----
{@defer [output=OUTPUT] ... }
----

[NOTE]
====
You probably want to use the macro `defer` with the `@` character in front of the macro name.
If you use `#`, then the content is evaluated before the macro `defer` is executed.
In this case, the macro sees the evaluated input and will defer the evaluation of the already evaluated text to the end of the execution.
====

In the following, we will give some examples.

This example is the simplest.
It defers an empty string.


.Jamal source
[source]
----
{@defer}
Original result.
----

When the empty string is evaluated nothing happens, the original output is retained:

.output
[source]
----
Original result.
----


The second example is a bit more complex:

.Jamal source
[source]
----
{@defer {#define $output={$input}{$input}}}\
Is this doplikated?
----

In the deferred evaluation the macro `$output` is defined, and it will be the same as the `$input` repeated.

.output
[source]
----
Is this doplikated?Is this doplikated?
----


The next example demonstrates that

- the name of the input and output macros can be redefined, and
- multiple `defer` macros are executed in the order as they were evaluated in the input during the Jamal processing.

.Jamal source
[source]
----
{#block
{@define $output=OUT}\
{@define $input=IN}\
{@defer
{#define OUT=|{IN}|}\
}\
}\
{@defer {#define $output=*{$input}*}}\
Framed
----

Note that the definition of the macros `$input` and `$output` are local to the `block` and therefore they have no impact on the second defer.
Since the `{#define OUT=|{IN}|}` is defind before `pass:[{#define $output=*{$input}*}]` the text `Framed` is enclosed first between `|` characters and only the result is enclosed between `pass:[*]`.

The output is:

.output
[source]
----
*|Framed|*
----


The next example is almost the same as the previous.
It uses macro options to set the input and output names for the first `defer` macro:

.Jamal source
[source]
----
{@defer [input=IN output=OUT]
{#define OUT=|{IN}|}\
}\
{@defer {#define $output=*{$input}*}}\
Framed
----

In this case there is no need for the `block` macro, since option setting is always local to the macro where it is set.
The result is the same as in the previous case:

.output
[source]
----
*|Framed|*
----


The next example shows that you do not need to use the input at all to set the output.

.Jamal source
[source]
----
{@defer
{#define $output=}{@comment just nothing}
}\
Is this ignored?
----

In this case the output is an empty string

.output
[source]
----

----


The following sample shows that the macros used in the text of `defer` have to be defined only when it gets executed.
In the example the macro `doplikate` is not defined when used in `defer` only at the end of the file.

.Jamal source
[source]
----
{@defer
{#define $output={doplikate/{$input}}}
}\
Annoying?{@define ~ doplikate(a)=aa}\
----

The output is:

.output
[source]
----
Annoying?Annoying?
----


The following example is a bit more complex.
In this case the code uses the `escape*` macro.

.Jamal source
[source]
----
{@escape*````}\
{@defer
{#define $output={doplikate/{$input}}}{@comment DEBUG}
}\
{@escape* ``{mememe}``}Mememe?{@define ~ doplikate(a)=aa}\
----

In this case there are two deferred operations.
The first one is the unescaping of `escape*`.
This is executed first, because the use of the first `escape*` macro precedes the macro `defer`.
When this unescaping is finished the result of the processing will be `{mememe}Mememe?`.
It contains a string that can be interpreted as a macro.
For this reason the macro `doplikate` is defined as a "verbatim" macro.
This is signalled by the `~` character after the `define` keyword.
Verbatim user defined macros are not post evaluated.
When `doplikate` is invoked in the `defer`, then `{mememe}Mememe?` will be converted to `{mememe}Mememe?{mememe}Mememe?`.
This result also will not be evaluated again.

However, when we set the macro `$output` in the line `{#define $output={doplikate/{$input}}}` why `{mememe}Mememe?` is not evaluated.
The reason is that the user defined macro `$input` holding the final result of the Jamal processing is also a verbatim macro.

The output is:

.output
[source]
----
{mememe}Mememe?{mememe}Mememe?
----


Although `$input` is verbatim, `$output` does not need to be.
This macro is used temporarily by the deferred action to change the output of Jamal processing.
The following example shows that the value of `$output` is not available as input for `defer`.
The macro `$output` can only be set by the input of `defer` and `$output` is undefined when the evaluation starts:

.Jamal source
[source]
----
{@defer {#define $output=aaa{?$output}}}\
{#define $output=this will not survive}
Annoying?
----

This example tries to use the value of the macro `$output` in the deferred code.
The deferred code can rely on the macros defined during the Jamal processing.
Note, however that only the top level macros are available as all other macros are out of scope and only those, which were defined at the end of the Jamal processing.

The macro `$output`, however, is used in a special way.
Because it serves to pass a modified output from the deferred code it is undefined before the deferred code start.
The result of this evaluation is:

.output
[source]
----
aaa
----


The macro `$output` gets undefined before the evaluation of each deferred code.
If we extend the previous example and define the output in one deferred code and try to use that in the next one it will still be undefined.

.Jamal source
[source]
----
{@defer {#define $output=this will not survive{?$output}}}\
{@defer {#define $output=aaa{?$output}}}\
{#define $output=this also will not survive}
Annoying?
----

The output is still:

.output
[source]
----
aaa
----


The last example shows that other macros survive and can be used in subsequent deferred actions.
If the macro `doplikate` is defined in a deferred action, then the subsequent deferred actions can use the macro:

.Jamal source
[source]
----
{@defer {#define $output=|{$input}|}}\
{@defer {@define ~ doplikate(a)=a/a}}\
{@defer {#define $output={doplikate {$input}}}}\
wuff
----

And the output is:

.output
[source]
----
|wuff|/|wuff|
----
