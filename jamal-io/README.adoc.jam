= Jamal IO module

{%@import res:jamal.jim%}\
{%#counter:define id=macroChapter {%@define format=$roman. %}%}\
{%@define RECURSIVE=`io:recursive` (alias `recursive`) is a boolean option controlling if the deletion should be recursive%}\
{%@define OUTPUT_FILE=`io:outputFile` (aliases `io:output`, `output`, `io:file`, `file`) can define the name of the file.%}\
{%@define OPTIONS_NOTE=
Note that the option can be defined as a user defined macro or as an option using the `{@option ...}` macro.
The aliases can only be used on the macro itself after the name of the macro between `(` and `)` characters.%}\
{%@define NO_PARENTHESIS_NOTE=Note that this macro reads the options directly from the input, and they are not enclosed between `(` and `)` characters.%}\
Using this module, you can handle files from a Jamal source code.
You can

* create a file,

* write text to the file,

* create directories,

* delete directories, files and

* you can print messages to the standard output or to the standard error.

To use this module, you have to add the dependency to your Maven project, as:
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-io</artifactId>
    <version>{%VERSION%}</version>
</dependency>

----

Following that, you can use the macros
{%@define chap($x)=. <<$x,`io:$x`>>%}

{%chap write%}
{%chap remove%}
{%chap mkdir%}
{%chap print%}
{%chap exec%}
{%chap waitFor%}

{%@define chap($x)=[[$x]]
=== {%macroChapter%}`io:$x`
%}{%@define link($x)=<<$x,`io::$x`>>%}
macros.

{%@define section($x)===== $x%}

== Macros implemented in the package

{%chap write%}

Using this macro you can write some text into a file.
The format of the macro is

{%sample/
{@io:write (options) text to write into the file}
%}

The macro will write the input of the macro to a text file.
The name of the file and write mode can be controlled using options.
The options are:

* {%OUTPUT_FILE%}

Use the user defined macro if you want to write several different segments to the file, and you do not want to specify the name of the file every the time.

* `io:append` (alias `append`) is a boolean option controlling if the content should be appended, or the file has to be truncated.
The default value is to truncate the file.

* `io:mkdir` (alias `mkdir`) is a boolean option controlling if the directory where the file has to be is created before writing the file if it does not exist.
The default is not to create the file.

{%OPTIONS_NOTE%}

{%chap remove%}

This macro can be used to remove a file or directory.
The format of the macro is

{%sample/
{@io:remove options}
%}

The options are:

* {%OUTPUT_FILE%}

* {%RECURSIVE%}

{%NO_PARENTHESIS_NOTE%}

{%OPTIONS_NOTE%}

{%chap mkdir%}

This macro can be used to create a directory.
The format of the macro is

{%sample/
{@io:mkdir options}
%}

The options are:

* {%OUTPUT_FILE%}

* {%RECURSIVE%}

{%NO_PARENTHESIS_NOTE%}

{%OPTIONS_NOTE%}

{%chap print%}

This macro can be used to print some text to the standard output or to the standard error.
The format of the macro is

{%sample/
{@io:print (options) message to print}
%}

There is one option.

* `io:err` (alias `err`) is a boolean option controlling if the message should be written to the standard output or to the standard error.
The default is the standard output.

{%OPTIONS_NOTE%}

{%chap exec%}
{%@snip:collect from=src/main/java/javax0/jamal/io/Exec.java%}

This macro can start an external program.
The typical use is to start an external document handling program, like GraphWiz, which cannot be integrated in-process.
The format of the macro is

[source]
----
{@io:exec options
input text}
----

The first line of the macro following the name of the macro contains the options.
The rest of the macro will be used as the input text to the program, and Jamal will feed it into the standard input of the program.

Note that it is not possible to execute an arbitrary program from Jamal.
Anything you want to execute as a separate process has to be configured in the system.
For security reason, the command specification is a symbolic name.
The executable should be configured in an environment variable, a system property or a Jamal configuration in the `~/.jamal/setup.properties` or `~/.jamal/setup.xml` file.
The recommended way to configure the executable is to use the `~/.jamal/setup.properties` or `~/.jamal/setup.xml` file.

For example, if you want to execute the GraphWiz program, you can configure it in the `~/.jamal/setup.properties` file as:

[source]
----
GraphWiz=/opt/local/bin/graphviz/bin/dot
----

After this you can execute the macro

[source]
----
{@io.exec command=GraphWiz}
----

This will start the program without any argument, defined timeout or input text.

The options of the macro are defined as follows:

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*Params\\..*holder\\(null,(.*?)\\).*~* $1~.*//\\s*~" replace="~\"(\\w)~`$1~(\\w)\"~$1`~"
{%@snip exec_options%}
%}%}

{%@define ALIAS$ONLY=
Note that all these options are technically aliases.
It means that you cannot use a user defined macro to specify their values.
They all have to be specified in the first line of the macro.%}{%ALIAS$ONLY%}

{%@snip:collect asciidoc from=src/test/java/javax0/jamal/io/TestExec.java%}}

{%@define example($x)=[source]
----
{%#replaceLines replace="~System\\.setProperty\\(\"(\\w+)\", \"(\\w+)\"\\);~$1 -> $2~" \
                replace=~^\s*~~ \
                replace="~([^\\\\])\"~$1~" \
                replace="~^\"~~" \
                replace="~\\+$~~" \
                replace="~\\\\\"~\"~" \
                replace="~\\\\n~\\n~"
{%@snip $x%}
%}
----%}

{%section Examples%}

In the followings we will list some examples of the use of the macro `exec`.
These examples are collected from the integration test file `{%@file src/test/java/javax0/jamal/io/TestExec.java%}`.
The first line of the examples is the definition of the command in the format `symbol -> value`.
The integration test sets these values as Java system properties.
The rest of the lines contain the macro as it appears in the test code.

[NOTE]
====
When Jamal looks for some configuration it looks at the

* system properties

* environment variables

* `~/.jamal.setup.(properties|xml)`

whichever it finds first.
The key given is used as is in the case of the environment variables.
For example `JAVA_HOME` is used as is.
However, when the code looks at the system properties, it looks for the key `java.home`.
The transformation is to contert to lower case and replace the underscore characters with dot.
In the configuration file the key is also lowe case and the underscore characters are replaced with dot but if the key has a `jamal.` prefix it is also removed.
This is the reason why the sample code defines `exec` in lower case and `EXEC` in upper case in the macro.
====

This example starts java to echo the version of the installed and used Java.
{%example java_echo_version%}
{%@snip:check id=java_echo_version hashCode=26ad2559%}


This example will print the current working directory.
Because the current working directory is changed by the option `cwd=target` the result will be this directory.
Note, however, that changing the working directory for the new process does not effect the parameters of the macro.
The other parameters, like `output` still have to define the file names absolute, or relative to the file containing the macro.

{%example pwd%}
{%@snip:check id=pwd hashCode=10149685%}

The following example calls the command `cat` which copies the standard input to the standard output.
The standard input is not defined in the macro, therefore the text after the first line is used.
The output is redirected into a file.
The file will contain the text from the macro.

{%example cat%}
{%@snip:check id=cat hashCode=c679a2f1%}

[NOTE]
====
This is a system dependent and rather slow way to write something into a file.
The `io` module provides a more efficient way to write into a file.
====

The next example calls the `echo` program that prints the argument to the standard output.
Since no output file is defined the output is the result of the macro.

{%example echo%}
{%@snip:check id=echo hashCode=df355a0a%}

The next sample calls a shell script.
The content of the schellscript is

[source]
----
sleep 1
echo hello
----

The command is invoked asynchronously.
It means that the macro does not wait for the completion of the process.
The output of the process is not redirected to a file, and because it is asynchronous the output is thrown away.
The result of the macro is empty string.
The option async defines a name for the process, `PROC001`.
This name can later be used to reference the process in the macro `waitFor`.
In this example we do not wait for the process to finish, not even later.

{%example sleep%}
{%@snip:check id=sleep hashCode=06f322bc%}


The next example calls the `sleep` program that sleeps for 1000 of seconds.
We start the process in a synchronous mode and we wait for it 1000 milliseconds.
Note that the `argument` to the proces, sleep is `1000` and the timeout value is also `1000`.
However, the program `sleep` interprets the argument in seconds, while the option `wait` is milliseconds.
Evidently the wait time will timeout and after that Jamal will stop the external process.

{%example timeout%}
{%@snip:check id=timeout hashCode=6ed4e82c%}


This example is a demo setting the environment variables.
The external program prints out the environment variable `AAA`.
The macro sets the environment variable `AAA` to `BBB`.
The example shows a multipline example of environment variable setting demonstrating empty line and a comment line as well.
The new value is added to the existing envrionment variables that the new process inherits from the Jamal executing process.

{%example env%}
{%@snip:check id=env hashCode=d645bcfb%}

This exaple is similar to the previous one,but it resets the environment variables.
The environment printout in the new process will print the value of the environment varianle `JAVA_HOME`.
This environment variable should be defined in the environment where Jamal runs because Jamal is written in Java.
On the other hand the external program will see this environment variable as undefined and the output of `printenv` is an empty string.

{%example env_reset%}
{%@snip:check id=env_reset hashCode=cbb3ba3b%}



{%chap waitFor%}

This macro can be used to wait for the completion of a proces started earlier asynchronously.
A document may start some external process at an earlier point and needs the result only later.
While the external processess runs the document processing can go on and the wait for the result when it is needed.
The output of the external process cannot be collected from the result of the `exec` macro.
Output of asynchronously started external processes do not appear as the result of the macro.
In this case the output is typically redirected to a file and the result can be collected from the file after the `waitFor` was processed.

The macro `waitFor` uses a subset of the options of the `exec` macro.{%ALIAS$ONLY%}

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*Params\\..*holder\\(null,(.*?)\\).*~* $1~.*//\\s*~" replace="~\"(\\w)~`$1~(\\w)\"~$1`~"
{%@snip waitFor_options%}
%}%}

{%section Examples%}

The following example starts a one-second sleep as a separate process asynchronous.
After that in the next macro it waits for the process to finish.

{%example wait_for%}
{%@snip:check id=wait_for hashCode=0c4852d2%}

The next example starts a ten-second sleep asynchronously.
After that in the next macro it waits for the process to finish with a one seond timeout value (1000ms).
It eventually will not finish during this time and then the macro will terminate the external process.

{%example wait_for_timeout%}
{%@snip:check id=wait_for_timeout hashCode=5a7b1bf4%}
