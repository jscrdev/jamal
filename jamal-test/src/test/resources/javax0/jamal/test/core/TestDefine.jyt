{%@comment
When the user defined macro name itself is defined as the result of a macro evaluation it is forbidden to get the
separator character as the result of the evaluation. In this case `z` is evaluated to `a|` and that would make
`|` to the separator character for the arguments (we have here only one).
%}

A macro name can be defined as the result of a macro:
  Input: |
    {@define z=a|}\       {%@comment when this is used as macro it will be invalid%}
    {@define a(k)=hkh}\
    {@try! {{z}K}}{%@comment {z}K will become a|K, which would be ok, but the | comes from the macro%}
    {@define z=a}\
    {{z}|K}{%@comment {z}|K will become a|K, which is be ok, the | comes from the use and not the macro hidden%}
    this would be correct

  Output: |
    Macro evaluated result user defined macro name contains the separator. Must not.
    hKh
    this would be correct

First character is used as spearator, it cannot be an alpha character:
  Input: "{@try! {@define a(b,c)=bika cica}{a HkukkHmukk}}"
  Output: "Invalid separator character 'H' "

macro can be defined when another macro is evaluating:
  Input: |
    {@define firstName=Julia}{@define k(h)=h, {firstName} h{@define son=Junior h}}\
    {k /Bond{@define firstName=James}}
    {son}
    {k /Band}
    {son}
  Output: |
    Bond, James Bond{%@comment this the local value of the macro `firstName`%}
    Junior Bond
    Band, Julia Band{%@comment this the global value of the macro `firstName`%}
    Junior Band

Verbatim use of a user defined macro also closes the scope:
  Input: "{@define a=this is it}{@define b={a}}{#define c={@verbatim b}}{c} {@verbatim c}"
  Output: "this is it {a}"

Lenient allows more argument than needed:
  Input: "{@options lenient}{@define z()=zzz}{z aaa}"
  Output: "zzz"

Lenient allows less argument than needed:
  Input: "{@options lenient}{@define z(k,h)=kzzzh}{z :aaa}"
  Output: "aaazzz"

Documentation fish test:
  Input: |-
    {@define z(*a,*b,*c,*d)=When a *a can *b then *c can *d}
    {z /leopard and a *c/run/fish/fly}
  Output: "\nWhen a leopard and a *c can run then fish can fly"

With the 'define !' you cannot redefine a macro, throws exception:
  Input: "{@define a=1}{@define ! a=2}"
  Throws: "The macro 'a' was already defined."

With the 'define !' you cannot redefine a macro even in inner scope, throws exception:
  Input: "{@define a=1}{#block {@define ! a=2}}"
  Throws: "The macro 'a' was already defined."

Invalid macro evaluation:
  Input: |-
    {@try! {@define z=a}{@define su=/}
    {@define a(k)=hkh}
    {{z}{su}K}}
  Output: "Macro evaluated result user defined macro name contains the separator. Must not."

Recursive definitions work:
  Input: |-
    {@define wilfred=define}{#{wilfred} alfred=wilfred}{alfred}
    {@define black=white}{@define white=black}{{black}} {{{black}}}
    {@define bla=whi}{@define ck=te}{{bla}\
    {ck}} {{{bla}{ck}}}
  Output: "wilfred\nblack white\nblack white"

{%@define OneArg($X)=One argument macro can use $X as a separator%}
{%OneArg space%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose this text}
  Output: |-
    <||this text||>

{%OneArg non-alpha character%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose|this text}
  Output: |-
    <||this text||>

{%OneArg non-alpha character after space%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose |this text}
  Output: |-
    <||this text||>

{%OneArg non-alpha character after space followed by other non-alpha%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose |+this text}
  Output: |-
    <||+this text||>

{%OneArg non-alpha character after space followed by same non-alpha%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose ||this text}
  Output: |-
    <|||this text||>

{%OneArg non-alpha character after space followed by space%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose | this text}
  Output: |-
    <|| this text||>

{%OneArg non-alpha character after space, argument containing the separator%}:
  Input: |-
    {@define enclose(a)=<||a||>}\
    {enclose | this||text}
  Output: |-
    <|| this||text||>

One argument macro can get the argument from the evaluation of another macro:
  Input: "{@define a(x)=<<|x|>>}{@define b=55}{a {b}}"
  Output: "<<|55|>>"

Test globally defined macro optional redefinition using local name:
   Input: "{@define :a=1}{#ident {@define ?a=2}{a}}"
   Output: "1"

Test globally defined macro optional redefinition using global name:
   Input: "{@define :a=1}{#ident {@define ?:a=2}{a}}"
   Output: "1"

Test globally defined macro optional redefinition in local scope:
   Input: "{@define :a=1}{#ident {@define ?:a=2}{:a}}"
   Output: "1"

Double verbatim character in define is an error:
  Input: "{@define ~?~ a={@code}}{a}"
  Throws: "define.*has no.*"

Macro defined to be verbatim:
  Input: "{@define~ a={@code}}{a}"
  Output: "{@code}"

Macro defined verbatim using the ~ sign after a space:
  Input: "{@define ~ a={@code}}{a}"
  Output: "{@code}"

Optional redefine to be verbatim:
  Input: "{@define ?~ a={@code}}{a}"
  Output: "{@code}"

Error redefine to be verbatim:
  Input: "{@define !~ a={@code}}{a}"
  Output: "{@code}"

Verbatim error redefine to be verbatim:
  Input: "{@define ~! a={@code}}{a}"
  Output: "{@code}"

Verbatim optional redefine to be verbatim:
  Input: "{@define ~? a={@code}}{a}"
  Output: "{@code}"

Verbatim macro post evaluated is the same as non-verbatim macro:
  Input: "{@define b=2}{@define ~ a={b}}{!a}"
  Output: "2"