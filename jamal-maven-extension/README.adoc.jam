= Jamal Maven Extension
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}
This module lets you maintain your `pom.xml` files using Jamal macros.
To use this module create a `.mvn` in your project root.
This directory should contain the file `extensions.xml` with the content:

[source,xml]
---
<?xml version="1.0" encoding="UTF-8"?>
<extensions>
    <extension>
        <groupId>com.javax0.jamal</groupId>
        <artifactId>jamal-maven-extension</artifactId>
        <version>{%VERSION%}</version>
    </extension>
</extensions>
---

When you start Maven, it will read the `pom.xml.jam` file, convert it using Jamal and create the {%@file (format=`$name`)pom.xml%} file.
If it does not find a `pom.xml.jam` it will also try `pom.jam`.

[NOTE]
====
The actual process is the following.
When a user invokes Maven, it looks at the `extensions.xml` file and sees that the Jamal Maven Extension is configured there.
It loads the Jamal Maven Extension and invokes it to locate the POM file.
This call assumes that the file is already there, and at this point, the extension is supposed to find it simply.
The extension, however, reads the `pom.xml.jam` or `pom.jam` file and processes it.
The processing includes the resolution of all the macros and the formatting of the final XML result.
When the extension is done with this step, it writes the `pom.xml` file and returns the file reference as a Java `File` object.

Maven later asks the extension to load the project object model from this file.
The extension knows at this point that the generated `pom.xml` file is a standard XML formatted pom, and it simply asks the standard Maven Platform Reader to read it.
When the Maven Platform Reader returns with the object model, the extension passes it back to Maven, and the rest is standard Maven business as usual.

image::{%@plantuml (folder=.) call-sequence.svg
@startuml
actor User
skinparam style strictuml
User -> Maven : mvn verify
Maven -> Maven : read .mvn/extensions.xml
Maven -> "Jamal Maven Extension" : LOAD
Maven -> "Jamal Maven Extension" : get pom structure
"Jamal Maven Extension" -> Jamal : process pom.xml.jam
"Jamal Maven Extension" <-- Jamal : result
"Jamal Maven Extension" -> "Jamal Maven Extension" : save pom.xml
Maven <- "Jamal Maven Extension" : pom.xml file
Maven -> "Jamal Maven Extension" : get pom structure
"Jamal Maven Extension" -> "Maven Plaform Reader" : read the pom.xml
"Jamal Maven Extension" <-- "Maven Plaform Reader" : pom structure
Maven <-- "Jamal Maven Extension" : pom structure
Maven -> Maven : build
User <-- Maven : done
@enduml
%}[]
====

== Using the generated `pom.xml`

The created {%@file (format=`$name`)pom.xml%} is saved to the directory and not removed after it was processed.
It is also available for the IDE, which may not read the macro enhanced POM file.
You can add it to your source control if you wish.

== Converting your project to use `pom.jam`

When you want to convert a project to use the Jamal maven extension you only have to

1. create the `.mvn` directory

2. create the `extensions.xml` file

3. rename the existing `pom.xml` files to `pom.jam`.

When you have a multi-module project this can be cumbersome and error prone.
To automate this the Jamal Maven plugin can be started with the command line

[source]
----
mvn -Djamalize=true com.javax0.jamal:jamal-maven-plugin:{%VERSION%}:jamal
----

from the top level project directory.

The Jamal plugin will scan all the

== Getting Rid of the Extension

It may happen that, for some reason, you want to get rid of the extension.
The reasons can be various.
The maintenance of the project is passed on to a team that is not knowledgeable about Jamal.
A new corporate policy may exclude external tools or restrict the extensions and plugins you can use with Maven.
You may run into some unforeseen complexity problem using Jamal, and you may not have time to debug your macros.
It is straightforward to revert the operation to standard Maven compilation temporarily or final in any of those cases.

This extension retains the XML format as opposed to Polyglot Maven, where you use a Java, Kotlin, Yaml, etc., based DSL instead of XML.
You do not need any conversion step from DSL to XML; the {%@file (format=`$name`)pom.xml%} is always there.
What you have to do to revert the operation to standard Maven and `pom.xml` based compilation is to remove the `.mvn` directory.

If the reverting to standard `pom.xml` based compilation is final, then do not forget to remove the `.mvn` directory from the source control.

== Error Handling and Debugging
{%@snip:collect from="../jamal-api/"%}
If there is an error processing the Jamal file or XML formatting, the extension will give a very detailed stack trace.
Jamal can also be debugged as described in the link:../jamal-debug/README.adoc[debugger documentation].
You have to set an environment variable `{%@snip JAMAL_DEBUG_ENV /"(.*)"/%}` to be `http:8080`, start Maven, and when the debugger pauses, open `http://localhost:8080`.
(You can use any other port.)

The commands you will apply are:

[source,bash]
----
export {%@snip JAMAL_DEBUG_ENV /"(.*)"/%}=http:8080
mvn verify
unset {%@snip JAMAL_DEBUG_ENV /"(.*)"/%}
----

The extension is compatible with the Jamal Maven plugin so that you can generate the {%@file (format=`$name`)pom.xml%} file with command `mvn -f genpom.xml`.

== Available Macros

{%@define dependencies={%pom count(/project/dependencies/dependency/groupId[text()="com.javax0.jamal"]/../artifactId)%}%}
When Maven loads the Jamal Maven Extension, it recursively loads the dependencies of the artifact.
The dependencies configured are the followings:
{%@counter:define start=0 id=depCounter%}
{%@define further($MODULE)=For further information read the link:../jamal-$MODULE/README.adoc[documentation] of the module.%}

=== {%#comment {%depCounter%}%} `engine`
This module is the Jamal execution engine.
It is needed to execute Jamal.
The module does not provide macros.

=== {%#comment {%depCounter%}%} `groovy`
This module provides macros that allow embedding Groovy code into the `pom.xml.jam` file.
{%further groovy%}

=== {%#comment {%depCounter%}%} `ruby`
This module provides macros that allow embedding Ruby code into the `pom.xml.jam` file.
{%further ruby%}

=== {%#comment {%depCounter%}%} `scriptbasic`
This module provides macros that allow embedding ScriptBasic code into the `pom.xml.jam` file.
{%further scriptbasic%}

=== {%#comment {%depCounter%}%} `snippet`
This module provides snippet macros.
{%further snippet%}

=== {%#comment {%depCounter%}%} `plantuml`
This module lets you embed PlantUML diagrams into your `pom.xml.jam` file.
I do not think that you would need anything like this, but if you need, there is no way to put it on the classpath other than listed here as a dependency.
{%further plantuml%}

=== {%#comment {%depCounter%}%} `io`
This module provides macros that can help you read text from files and write text to external files.
{%further io%}

=== {%#comment {%depCounter%}%} `markdown`
This module lets you convert Markdown to HTML.
This module is mainly practical when you embed Jamal macros in a JavaDoc and use the Jamal doclet extension.
I do not see much use here, but the exact reason is to list it here as for the PlantUML module.
{%further markdown%}

=== {%#comment {%depCounter%}%} `yaml`
This module provides macros that can read, write and manipulate YAML data.
This macro package may be handy if you use macros that build up the POM structure in memory as a YAML structure.
There is a macro that can convert the built-up YAML structure as XML.
Although the conversion from Yaml to XML is limited, it may be very well suited to build up POM structures.
The current macros used in the Jamal projects and some other projects handle the POM structure as XML text and not as structure.
Managing and building up a structure would be much more powerful.
If you want to do anything like that, the in-memory Yaml structures these macros can manage are excellent for the purpose.

{%further yaml%}

=== {%#comment {%depCounter%}%} `assertions`
This module gives you assertion macros that can fail if certain conditions are not met.
{%further assertions%}

=== {%#comment {%depCounter%}%} `extensions`
It is an extension module with experimental macros.
The macros in this package are not supported and may change incompatible ways from version to version.
{%further extensions%}

=== {%#comment {%depCounter%}%} `debug`
This module does not provide any macro, but it has to be on the classpath to start the debugger.
A brief introduction is described above on how to start the Jamal processing when compiling a `pom.xml.jam.
{%further debug%}


{%#assert:equals /{%dependencies%}/{%depCounter%}/Not all dependencies are documented or some documented dependecy is not there any more%}