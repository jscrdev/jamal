



<h1>Docs as Code</h1>
<h2>it is the first step to the right direction</h2>

The approach to treat your documentation the same way as program code is a step into the right directions, but it is far from the state of the art. The practice is detailed on many web sites that advocate the use of docs-as-code (DAC). For example the <a href="https://www.writethedocs.org/guide/docs-as-code/">Write the Docs</a> community has a great article on docs-as-code. The article lists 
<ul>
  <li>Issue Trackers</li>
  <li>Version Control (Git)</li>
  <li>Plain Text Markup (Markdown, reStructuredText, Asciidoc)</li>
  <li>Code Reviews</li>
  <li>Automated Tests</li>
</ul>

as required tools to this approach. Another example is <a href="https://docs-as-co.de/">docs-as-code</a>, which is a toolset for documentation maintenance. They write 

<blockquote>
With docs-as-code, you treat your documentation in the same way as your code.

You useâ€¦

your IDE to write it
your version control system to store and version it
your test-runner to test it
your build system to build and deploy it"
</blockquote>

This is very much the same as the approach of <a href="https://www.writethedocs.org/guide/docs-as-code/">Write the Docs</a>.

<img src="https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-3.svg"/>

You have to have your documents in a format supported by the DAC tools. Use version control, document review, automated build, issue tracker and automated tests. It is very much the same approach that we are using in code development.

Essentially it is a copy of the professional software development process' coding part. Documentation, however, is not coding. While it is absolutely a good idea to reuse some parts of the coding methodology technics, there is more to it.

<img src="https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-4.svg"/>

<h1>What docs-as-code Ignores</h1>

Coding is a transformation process converting a documentation, namely the requirement documentation into code. The requirement documentation may not be a documentation in the classical sense. It may be some note, a list of wishes on a jot of paper. Still, the essence is to convert some human affine into machine affine. There are techniques that try to support this process, but most of these techniques died when in production. For example creating the documentation as UML and to make it so precise that the code generation is automatic afterwards is not feasible. It could be done in principle, but the cost of the effort is too high. It is cheaper to create the code rather than a documentation that defines the functionality with mathematical precision.

Documenting an application is exactly the opposite direction.

<img src="https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-5.svg"/>

Something that failed in one direction does not necessarily fail when we try to go the other direction. You may not be able to jump from the river on to the bridge, but the other way is very much possible.

When creating the program documentation our source is a precise description of the functionality we want to document. After all the most precise documentation of the application functionality is the code. In this case we already have the precision, which was not feasible to have for the other way around.

<img src="https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-1.svg"/>

This is ignored by the docs-as-code approach. However, it can be amended and it should be. We can look at it as the next step in the docs-as-code evolution.

<h2>The next step</h2>

We can categorize documentations into two categories. 
<ul> <li>Explanatory, and</li> <li>Reference</li> </ul>

Sometimes a document is clearly belong to one of the categories, but most of the times documents are a mix of the two. It may even happen that you cannot even tell if a sentence in a document belongs to one category or the other.

Creating an explanatory style text cannot be automated. It clearly needs human effort to create the sentences that are clear and easily understandable. The importance is clearly demonstrated by the lack of them in this article, as you may have noticed.

Creating the reference text, however, is more or less a mechanical task. The documentarian (a term from write-the-docs), for example, copies the name of the key to explain how to configure the system and writes a sentence around it. Copies some sample code from the unit tests into a code segment into the asciidoc documentation and adds explanation. In these examples the reference is taken from the code verbatim and the explanatory part is added.

The copy of the reference information can be automated. Most of the times it is not automated.

The catch is that automation, just as in the case of tests, is more expensive than doing the manual work once. It pays back when the actual operation (copy and paste) happens many times.

And it usually does. to be more precise, it is supposed to happen. However, in practice, the documentation maintenance misses the task and the document becomes stale. This is where the docs-as-code automated test may help. In principle it is possible to create a test cheking the documentation and find discrepancies between the names in the code and the documentation. It can be heuristic, or it can be exact. To do it the exact way the documentation and/or the code needs meta information helping the test to perform the consistency check.

Such a test can signal that the documentation may be outdate and may need change. For example it may give a warning, like

<blockquote> "The name of the field XYZ is not the same as in the documentation ZZZ. Change ZZZ in the documentation to XYZ". </blockquote>

This is an extremely stupid and outrageous error message. When I see an error message like that, I immediately know that the program architecture is messed up. If the test can tell me what to do with such a precision, it could, with the same effort fix the problem.

It is much better if we let the automated build copy the actual name instead of checking that it was done properly. To do that the documentarian should put the meta-information into the documentation instead of the copied value. The meta-information is read by the automated build tool, and using that it copies the actual value or values.

If the value changes the build process will automatically change it.

Another advantage is that the lesser possibility for error. If the documentarian makes a mistake copying the name of the field, the text will not complain. If he writes XXY instead of XYZ the documentation will contain the wrong name unless some human review process discovers and fixed the bug. If the documentarian inserts the meta information and makes a mistake, it is very likely that the build process will fail. If instead of XYZ, I have to write <tt>{java:field com.javax0.jamal.api#XYZ}</tt> any simple typo will be detected. If there is a field  <tt>com.javax0.jamal.api#XYZ</tt> it is unlikely to have also <tt>com.javax0.jamal.api#XXY</tt>.

<img src="https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-2.svg"/>

With this approach the docs-as-code workflow is extended.

They utilize <a href="https://jbake.org/">jBake</a>, which is an automation tool converting your source documentation to a final version. 