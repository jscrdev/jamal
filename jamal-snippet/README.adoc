== Jamal Snippet Handling Macros



Snippet handling macros help you to include information from program source code into the documentation automatically.

When you document an application, there is a lot of information that changes by changing the source code.
These changes have to be followed in the documentation.
Some changes need manual editing.
Some changes you can automate.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
We can hardly automate this change of the documentation.
When some literal parameter also used in the document changes, then Jamal can automatically update the documentation.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.5-SNAPSHOT</version>
</dependency>
----

You see in the `README.adoc` file the actual version number converted from the `README.adoc.jam`.
The original file, however, contains

[source,xml]
----
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed, the snippets will automatically contain the source code's actual text.
This way, it is easier to keep your documentation up to date.

=== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip:collect,`snip:collect`>>
.. <<snip:properties,`snip:properties`>>
.. <<snip:xml,`snip:xml`>>
.. <<snip:define,`snip:define`>>
.. <<snip:clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<snipList,`snip:list`>>
.. <<trimLines,`trimLines`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter:define,`counter:define`>>
.. <<reflow,`reflow`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<file,`file`>>
.. <<directory,`directory`>>
.. <<Java,Java Macros>>
.. <<snip:update,`snip:update`>>




[[usage]]
=== 1. Usage

If you are using Jamal programmatically or from Maven then the dependency you have to add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.5-SNAPSHOT</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java`; therefore, they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
=== 2. Macros

[[snip:collect]]
==== i. `snip:collect`
Since 1.7.4 option `onceAs`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect from="fileName" ...options}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file, then the macro will collect the single file's snippets.
If the `fileName` is a directory, then the macro will collect the snippets from the files in that directory and from directories beneath recursively.

A snippet in a file is a series of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the ending line.

[NOTE]
====
The definition and matching criteria of the start and the end of the snippet are very liberal.
The reason for that is to ease in recognizing these in different files.
The regular expressions will find snippet start and snippet ends in Java files, in XML, in Perl or Python code.
Essentially you should not have a problem signaling the start and the end of the snippet in any program code that allows you to write some form of a comment.

The disadvantage of this liberal definition is that sometimes it finds lines that accidentally contain the word snippet.
If you look at the source code in the file src/main/java/javax0/Jamal/snippet/TrimLines.java you can see examples.
The comment mentions snippets, and there is a word eligible to be an identifier after `snippet`, and the parsing thinks that this is a snippet start.
Eventually, there is no `end snippet` on the lines following it, which is an error the snippet collection process recognizes.
(Up to 1.7.2. Later versions use this file as a snippet source; thus, it has 'end snippet'.)
Still, you do not receive an error message.

That is because the collection process only recognizes this error but does not throw an exception.
The exception is thrown only when you want to use the `snip` macro for an unterminated snippet.

The possible situation may even be more complicated because the accidental word following `snippet` in a comment may also be used in other files as a snippet identifier.
The collector, sooner or later, will find that definition, and it will assume that the one with the error was just an accidental comment and replaces the old with the correct, error-free snippet.
It is still okay when the snippet collection finds these two snippets in the opposite order.
If there is already a correct, error-free snippet collected and the collection finds an erroneous one of the same name, it ignores that.

This way, the collection and the use of the snippets ignores the accidental snippet definitions, but at the same time, it can detect the mal-formed snippets.

If you look at the src/main/java/javax0/Jamal/snippet/TrimLines.javain version 1.7.3 or later, you can see that there is a `// snippet` line in the code.
Because there is also an accidental `snippet` line before it, the collection would not find this line.
Because of the previous `snippet` line, the real `// snippet` line becomes part of the previous snippet.
The `// snippet` line is preceded by an `// end snippet` line to avoid this.
Such a line out of a snippet is ignored, and in this case, it closes the accidental snippet.
====

As you can see, the regular expression contains a collection group, which Jamal uses as the name of the snippet.
For example, the code




[source]
----
// snippet sample
public class Sample implements Macro {

    @Override
    public String evaluate(Input in, Processor processor) {
        return in.toString()
            .replaceAll("^\\n+", "")
            .replaceAll("\\n+$", "");
    }
}
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The macro's input contains parameters.
These parameters are parsed using the Standard Parameter Parsing as defined in <<../PARAMS.adoc,PARAMS>>.
The parameters are `from`, `start`, `stop`, `include`, `exclude`, `onceAs`.

The snippet start and end matching regular expression can be redefined.
If the parameter `start` is defined, its value will be used as a snippet start matching regular expression.
It must have one collection group.
If the parameter `stop` is defined, then its value will be used as snippet end matching regular expression.

The collection of the files can also be controlled using parameters.
The parameters `include` and `exclude` can define regular expressions.
Only the files that match the regular expression specified by `include` and do not match the one set by `exclude` are collected when defined.

It is enough if the regular expressions match a part of the line, or the file name.

For example, the test file

[source]
----
{#snip:collect from="." exclude=2}
First snippet {@snip first_snippet}
2. snippet {@snip second_snippet}

Next file
{@try!
First snippet {@snip second_file_first$snippet}
Second snippet {@snip seconda_snippet_uniconde}
}
and this is the end
----

excludes any file that contains the character `2` in its name.

The parameter `onceAs` can be used to avoid repeated snippet collections.
Your collect macro may be in an included file, or the complexity of the structure of the Jamal source is complex.
At a certain point it may happen that the snippets you need were already collected, collecting it again would be erroneous.
When snippets are collected you cannot redefine a snippet.
If you define a parameter as `onceAs="the Java samples from HPC"` then the collect macro will remember this name.
If you try to collect anything with the same `onceAs` parameter the collection will simply ignore it.
It was already collected.

NOTE: This option was introduced to the `snip:collect` macro along with the Jamal doclet implementation.
When the individual documentation parts are processed in the same processor the processing order is not guaranteed.
If you want to refer to some snippets you have to collect them.
To do that you have to have the `snip:collect` in every JavaDoc, presumably using an imported file.
That collect macro should name the collection to avoid redefinition error.

[[snip:properties]]
==== ii. `snip:properties`

This macro will load properties from a "properties" file or from an "xml" file.
The names of the properties will become the names of the snippets and the values the values of the snippets.

For example, the sample

[source]
----
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
----


will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
a=letter a
b=    letter b
c = letter c
----

and thus using the `snip` macro, like

[source]
----
{@snip a}
----

will result



[source]
----
letter a
----


If the extension of the file is `.xml`, then the properties will be loaded as XML format properties.
For example the same properties file in XML format looks like the following:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <comment>Application Configuration</comment>
    <entry key="a">letter a</entry>
    <entry key="b">letter b</entry>
    <entry key="c">letter c</entry>
</properties>
----

[[snip:xml]]
==== iii. `snip:xml`

This macro loads an XML file and assigns it to a "user-defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

The defined `macroName` macro can be used as an ordinary user defined macro that accepts one argument.
This user defined macro evaluates in a special way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.

For example this document contains the following macros at the start:

[source]
----
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
----

The result is:

[source]
----
...
<version>1.7.5-SNAPSHOT</version>
...
----


which is the current version of the project as read from the `pom.xml` file.

[[snip:define]]
==== iv. `snip:define`

This macro can be used to define a snippet.
Snippets are usually collected from project files, but it is also possible to defined them via the macro `snip:define`.
For example,

[source]
----
{@snip:define mySnippet=
This is the snippet, which is defined inside the file and not collected from an external file
}
{@snip mySnippet
is used here and then the rest of the text is ignored}
----

will result



[source]
----
This is the snippet, which is defined inside the file and not collected from an external file
----


[[snip:clear]]
==== v. `snip:clear`

Calling this macro deletes all collected snippets from the memory.
The result of the macro is an empty string.

[[snip]]
==== vi. `snip`

The `snip` macro should have one argument, which should be the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip snipped_id comment}
----

is replaced by the content of the snippet named `snipped_id`.
The macro reads the ID from the input, and it purposefully ignores the rest of the input.
The reason to have the rest of the input as the comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code, but the same time it is not a problem if the copy gets outdated.
The output fetched the content from the actual value of the snippet.

Starting with Jamal version 1.7.2, the `snippet_id` can also be followed by a regular expression.
The regular expression can be used to extract and use a smaller part from the first line of the snippet.
The typical use is when there is a constant defined in the code and you want to reference the value of the constant.
In this case you can add

[source,java]
----
// snippet snippet_id
...
// end snippet
----

lines before and after the line defining the constant and add a regular expression that has one capturing group.
For example, you can have

[source,java]
----
// snippet defaultShellName
public static final String DEFAULT_RUBY_SHELL_NAME = ":rubyShell";
// end snippet
----

and the Jamal code

[source,text]
----
{#define defaultShellName={@snip defaultShellName /"(.*)"/}}\
----

to gauge out the string `:rubyShell` from the source code.

If the first character after the `snippet_id` is a `/` character, then the macro will treat the rest of the input as a regular expression.
This part also has to end using a `/`.
The characters between the first and the last `/` are interpreted as a regular expression.
This regex has to have at least one capturing group.
The string captured by the first group will be returned by the macro.
The characters that follow the last `/` character are ignored, and eventually can not contain any more `/` characters.

If the regular expression is not find in the first line of the snippet, or there is no capturing group, then the first line itself will be the result of the macro.

[[snipList]]
==== vii. `snip:list`

This macro list the defined snippets.
The list is represented as a comma delimited list, which contains the names of the snippets.

There are four parameters the macro handles, all are optional:

* `name` (can be aliased as `id`) for the name of the snippet

* `file` for the file name of the snippet

* `text` for the contect of the snippet

* `listSeparator` can redefine the list separator. The default is comma.

The first three parameters are interpreted as regular expressions.
If any of them missing or empty string then the parameter is not taken into account.

The listing will filter the snippets to include only those into the list that

* the name of the snippet matches the parameter `name`, and

* the file name, from which the snippet was harvested matches the parameter `file`, and

* at least one line of the snippet matches the parameter `text`.

The matching means that the regular expression should match part of the text.
If you want to match the whole name, file name or content line you have to use a `^ ... $` format regular expression.

If all the parameters are missing then the macro will list all the snippet names.

[[trimLines]]
==== viii. `trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When a code fragment is included in the documentation as a snippet, the lines may have extra spaces at the start.
That is when the fragment comes from a code part that is somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
This way the code formatting remains the same as in the source code, but the code sample will be aligned to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

[source]
----
{@trimLines
  k
   a
   b
 c
}
----

will result

[source]
----
 
 k
  a
  b
c


----


The lines to be trimmed should start on the line following the name of the macro.
The characters following the macro name to the end of the line are parsed for options.
Options currently are:

* `margim` can specify the minimum number of spaces that have to appear in front ofevery line.
Using this option you can even insert extra spaces in front of the lines while keeping the tabulation.

* `trimVertical` is a boolean parameter to remove the new line character from the start and from the end of the sample.
This eliminates the leading and trailing empty lines.

* `verticalTrimOnly` (alias `vtimOnly`) instructs the macro to do only the vertical trimming.
If this option is defined there is no need to define `trimVertical` also.

The macro can also delete the empty lines from the start and from the end of its input in case the option `trimVertical` is set.
For example

[source]
----
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
----

will result

[source]
----
 
k
 a
 b
c

----


[[numberLines]]
==== ix. `numberLines`

This macro can put numbers in front of the lines, sequentially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default, the numbering of the lines start with one and every line gets the next number.
For example

[source]
----
{@numberLines
this is the first line
this is the second line
this is the third line
}
----

will result

[source]
----
1. this is the first line
2. this is the second line
3. this is the third line
----


The number will be inserted with a `.` (dot) after the number and a space.

The parameters `start`, `step` and `format` can define different start value, step value and format for the numbers.
For example

[source]
----
{#numberLines start=3 step=2 format=" %03d::"
this is the first line
this is the second line
this is the third line
}
----

will result

[source]
----
003::this is the first line
005::this is the second line
007::this is the third line
----


The formatting will be used in the method `String::format`.
Any illegal formatting will result an error.

[[killLines]]
==== x. `killLines`

This macro deletes selected lines from its input.

The first line following the macro identifier until the end of the line may contain parameters.
These parameters are parsed using the Standard Parameter Parsing as defined in <<../PARAMS.adoc,PARAMS>>.


The format of the macro is

[source]
----
{@killLines parameters

 ...

}
----

By default, the lines, which contain only spaces are deleted.
The parameter macro `pattern` may define a regular expression that can be used to select the lines.

For example:

[source]
----
{#killLines pattern=^\s*//
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
----

creates the output

[source]
----
/* this stays */

#define VERSION 1.0 //this line also stays put
int j = 15;
----


[[skipLines]]
==== xi. `skipLines`

This macro can be used to skip lines from the snippet.
It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip` then the line, and the following lines are deleted from the output until a line matching `endSkip` is matched.
The lines that match the regular expressions are also deleted.

For example,

[source]
----
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines
----


You can also define the regular expressions defining the parameters `skip` and `endSkip`.
For example,

[source]
----
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines
----


It is not an error if there is no line matching the `endSkip`.
In that case all lines starting with the line matching the `skip` will be removed from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip` then any further `skip` is ignored until an `endSkip` is found.

[[replace]]
==== xii. `replace`

The macro `replace` replaces strings to other strings in its input.
 The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It uses the first argument as the input and then every following argument pairs as search and replace strings.
For example:

[source]
----
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
----

will result:

[source]
----
the pear has fallen off the bush
----


If the option `regex` is active, then the search string are treated as regular expressions and the replace strings may also contain replacement parts.
For example,

[source]
----
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
----

will result the same output

[source]
----
the pear has fallen off the bush
----

but this time the replace used regular expression substitution.

[[replaceLines]]
==== xiii. `replaceLines`

This macro replaces strings in the input.


The first line following the macro identifier until the end of the line may contain parameters.
These parameters are parsed using the Standard Parameter Parsing as defined in <<../PARAMS.adoc,PARAMS>>.


It works similarly to the macro <<replace,`replace`>>.
The difference is that the replace

* is always based on regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the start or at the end of the line.
For example,

[source]
----
{@define replace=/^\s+\*\s+//}
{@replaceLines
* this can be a snippet content
* which was collected
* from a Java or C program comment
}
----

will result

[source]
----
* this can be a snippet content
* which was collected
* from a Java or C program comment
----


The search regular expressions, and the replacement strings have to be defined in the parameter `replace`.
This parameter can be defined inside the `replaceLines` macro.
The macro scans the value of the parameter `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It is usually an error when no lines are replaced in a snippet.
To detect this the parameter`detectNoChange` can be used.
If this boolean parameter is true, then the macro will result in an error if no line was changed.

[[counter:define]]
==== xiv. `counter:define`

This macro defines a counter.
The counter can be used like a parameterless user defined macro that returns the formatted actual value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define id=identifier}
----

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

[source]
----
{@counter:define id=c} {c} {c} {c}
----

will result

[source]
----
1 2 3
----


You can define the start, and the step value for the counter as well as the format.
For example,

[source]
----
{#counter:define id=c{@define start=2}{@define step=17}} {c} {c} {c}
----

will result

[source]
----
2 19 36
----


The format can contain the usual `String.format` formattings.
In addition to that it can also contain one of the `$alpha`, `$ALPHA`, `$roman` or `$ROMAN` literals.

* `$alpha` will be replaced by `a`, `b`, ... , `z` for 1, 2, ... , 26 counter values.
* `$ALPHA` will be replaced by `A`, `B`, ... , `Z` for 1, 2, ... , 26 counter values.
* `$roman` will be replaced by the lower case roman numeral format for 1, 2, ... , 3999 counter values.
* `$ROMAN` will be replaced by the upper case roman numeral format for 1, 2, ... , 3999 counter values.

It is an error

* if either `$alpha` or `$ALPHA` is used in the format, and the value is zero, negative, or larger than 26, or
* if either `$roman` or `$ROMAN` is used in the format, and the value is zero, negative, or larger than 3999.

Examples:

[source]
----
{#counter:define id=cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define id=aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define id=AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define id=rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define id=RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
----

The output will be


[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.
----


[[reflow]]
==== xv. `reflow`

This macro reflows the content of it.
The default behaviour is that the lines will be any long and the paragraph will be separated by double new-lines.

For example:

[source]
----
{@reflow
The
short
lines
will
be put into a single line.

Empty lines are paragraph limiters.




Multiple empty lines are
converted to one.}
----

The output will be


[source]
----
The short lines will be put into a single line.

Empty lines are paragraph limiters.

Multiple empty lines are converted to one.
----


If the parameter `width` specifies a positive integer number, then it will be used to limit the length of the lines.
For example

[source]
----
{@define width=1}
{@reflow
The
long
lines
will
be broken into words.

Empty lines are paragraph limiters.}
----

The output will be


[source]
----
The
long
lines
will
be
broken
into
words.

Empty
lines
are
paragraph
limiters.
----


Setting the `width` to any non-positive value will remove the limit from the line length.

[[listDir]]
==== xvi. `listDir`

This macro list the files in a directory and then returns the comma separated list of the formatted files.
The format of the macro is:

[source]
----
{@listDir directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
For example,

[source]
----
{#for macroJavaFile in ({@listDir (format=$simpleName) ./src/main/java/javax0/jamal/})=
- macroJavaFile}
----

will result

[source]
----
- jamal
- snippet
- Snip.java
- Case.java
- NumberLines.java
- DateMacro.java
- Format.java
- Update.java
- FilesMacro.java
- Collect.java
- TrimLines.java
- Replace.java
- SnipXml.java
- Counter.java
- Clear.java
- KillLines.java
- SnippetStore.java
- ListDir.java
- XmlFormat.java
- SnipProperties.java
- CounterMacro.java
- SnipList.java
- XmlDocument.java
- Java.java
- ReplaceLines.java
- SkipLines.java
- Reflow.java
- Snippet.java
----


The listing of the files is recursive and is unlimited.
The limit of the recursion can be limited by defining the parameter `maxDepth`.
The same listing limited to 1 depth (non-recursive) is the following

[source]
----
{#for macroJavaFile in ({#listDir (format=$simpleName) ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
----

will result

[source]
----
- jamal
- snippet
----


The default formatting for the list of the files is the name of the file.
The parameter `format` can define other formats.
This format can contain placeholder, and these will be replaced with actual parameters of the files.
When used in a multivariable for loop then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders are:




* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.


For example,

[source]
----
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
----

will result

[source]
----
- jamal: 96 bytes
- snippet: 896 bytes
- Snip.java: 2,317 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,151 bytes
- DateMacro.java: 613 bytes
- Format.java: 930 bytes
- Update.java: 3,772 bytes
- FilesMacro.java: 4,763 bytes
- Collect.java: 5,498 bytes
- TrimLines.java: 3,687 bytes
- Replace.java: 1,775 bytes
- SnipXml.java: 1,511 bytes
- Counter.java: 3,323 bytes
- Clear.java: 434 bytes
- KillLines.java: 1,446 bytes
- SnippetStore.java: 9,845 bytes
- ListDir.java: 3,901 bytes
- XmlFormat.java: 3,331 bytes
- SnipProperties.java: 1,485 bytes
- CounterMacro.java: 1,811 bytes
- SnipList.java: 1,233 bytes
- XmlDocument.java: 2,038 bytes
- Java.java: 9,275 bytes
- ReplaceLines.java: 2,293 bytes
- SkipLines.java: 2,048 bytes
- Reflow.java: 1,716 bytes
- Snippet.java: 1,088 bytes
----



If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for colelction the files will follow symlinks.

[[xmlFormat]]
==== xvii. `xmlFormat`

The macro `xmlFormat` interprets the input as an XML document if there is any, and the result is the document formatted.
If the input is empty or contains only spaces, then it registers a post-processor that runs after the Jamal processing is done and formats the final output as XML.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.7.5-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.5-SNAPSHOT</version>
</project>
----


The default tabulation size is four.
You can alter it by defining the parameter `tabsize`.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.7.5-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<name>jamal snippet</name>
<packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId>
<artifactId>jamal-snippet</artifactId>
<version>1.7.5-SNAPSHOT</version>
</project>
----


As you can see there is no tabulation in this case.


There is another use of the macro `xmlFormat`.
If you do not include any XML, or anything else into the macro as input, then the macro will treat this as a command to format the whole output.
I registers itself into the processor and when the processing was finished this registered call-back starts and at that point it will format the output of the processing.
That way you can easily format a whole processed file.

The previous example that we used before can also be formulated this way.

[source]
----
{#xmlFormat}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.7.5-SNAPSHOT</version>
</project>
----

Note that the macro invocation `{#xmlFormat}` in this case can be anywhere in the input.
The formatting will take place postponed, when the processing is finished.
It will result the same output as before:

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.5-SNAPSHOT</version>
</project>
----


[[date]]
==== xviii. `date`

This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

[source]
----
{@date yyyy-MM-dd HH:mm:ss}
----

wll result the output

[source]
----
2021-04-27 13:03:14
----


[[format]]
==== xix. `format`

The macro `format` can be used to format the arguments.
 The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal all these arguments are strings.
Since the parameters to the underlying `String::format` method are not only strings they can be converted.
If any of the parameters starts with a `(xxx)` string, then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be


* `int`, the conversion will call Integer::parseInt.
* `long`, the conversion will call Long::parseLong.
* `double`, the conversion will call Double::parseDouble.
* `float`, the conversion will call Float::parseFloat.
* `boolean`, the conversion will call Boolean::parseBoolean.
* `short`, the conversion will call Short::parseShort.
* `byte`, the conversion will call Byte::parseByte.
* `char`, the conversion will fetch the first character of the parameter.

Examples:

[source]
----
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
----

wll result the output

[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437
----


[[file]]
==== xx. `file`

You can use this macro to include the name of a file in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the file, and it will appear in the output.

The real added value of the macro is that it checks that the file exists.
If the file does not exist or is not a file, then the macro will error.
It helps the maintenance of the application.
If the file gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the file.
It uses the value of the user-defined macro `fileFormat` for the purpose.
If this macro is defined outside the `file` macro, then the file names will be formatted using the same format.
For example, you can write

[source]
----
When Jamal processes this file it will generate {@define fileFormat=`$name`}{@file README.adoc}.
----

will result

[source]
----
When Jamal processes this file it will generate `README.adoc`.
----


In the format you can use the following placeholders:


* `$name` gives the name of the file as was specified on the macro
* `$absolutePath` the absolute path to the file
* `$parent` the parent directory where the file is
* `$canonicalPath` the canonical path


[[directory]]
==== xxi. `directory`

You can use this macro to include the name of a directory in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the directory, and it will appear in the output.

The real added value of the macro is that it checks that the directory exists.
If the directory does not exist or is not a directory, then the macro will error.
It helps the maintenance of the application.
If the directory gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the directory.
It uses the value of the user-defined macro `directoryFormat` for the purpose.
If this macro is defined outside the `directory` macro, then the directory names will be formatted using the same format.
For example, you can write

[source]
----
This file is in the directory {@define directoryFormat=`$name`}{@directory ../jamal-snippet}.
----

will result

[source]
----
This file is in the directory `../jamal-snippet`.
----


In the format you can use the following placeholders:


* `$name` gives the name of the directory as was specified on the macro
* `$absolutePath` gives the name of the directory as was specified on the macro
* `$parent` the parent directory
* `$canonicalPath` the canonical path



[[Java]]
==== xxii. Java Macros

[[java:class]]
===== `java:class`


The macro `java:class` checks that the parameter is a valid Java class and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the class mentioned in the documentation is still there, it was not deleted or renamed.

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the parameter `classFormat`.
For example:

[source]
----
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
----

wll result the output

[source]
----
The class that implements the macro `java:class` is
ClassMacro.
----


The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:


* `$simpleName` will be replaced by the result of calling `getSimpleName()`
* `$name` will be replaced by the result of calling `getName()`
* `$canonicalName` will be replaced by the result of calling `getCanonicalName()`
* `$packageName` will be replaced by the result of calling `getPackageName()`
* `$typeName` will be replaced by the result of calling `getTypeName()`


For example

[source]
----
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
----

wll result the output

[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.
----


It is not recommended overusing the format string.
Do not include verbatim text into the format string.
Choose a format string how you want to refer to the classes and use it globally in the document.

[[java:field]]
===== `java:field`


The macro `java:field` checks that the parameter is a valid Java field and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the field mentioned in the documentation is still there, it was not deleted or renamed.
In addition to that the value of the value of the field can also be used in the formatting in case the field is both `static` and `final`.
[source]
----
{@define field=javax0.jamal.api.SpecialCharacters#PRE_EVALUATE}
The field {#java:field (format="$name") {field}}
defined in the class {#java:field (format="$className") {field}}
is both `static` and `final` and has the value {#java:field (format="$value") {field}}
----

will result the output

[source]
----
The field PRE_EVALUATE
defined in the class javax0.jamal.api.SpecialCharacters
is both `static` and `final` and has the value #
----


The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:


* `$name` will be replaced by the name of the field
* `$classSimpleName` will be replaced by the simple name of the fields's defining class
* `$className` will be replaced by the name of the of the fields's defining class
* `$classCanonicalName` will be replaced by the canonical name of the fields's defining class
* `$classTypeName` will be replaced by the type name of the fields's defining class
* `$packageName` will be replaced by the package where the method is
* `$typeClass` will be replaced by the type of the field
* `$modifiers` will be replaced by the modifiers list of the method
                
* `$value` will be replaced by the value of the field in case the field is both `static` and `final`


[[java:method]]
===== `java:method`


The macro `java:method` checks that the parameter is a valid Java method and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the method mentioned in the documentation is still there, it was not deleted or renamed.

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the parameter `methodFormat`.
For example:

[source]
----
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
----

wll result the output

[source]
----
evaluate
----


The macro can have two-argument, using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>> or one specifying the full name of the method.
The full name of the method is the full name of the class and the same of the method separated by either a `#` character or by `::` characters.

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:


* `$classSimpleName` will be replaced by the simple name of the method's defining class
* `$className` will be replaced by the name of the of the method's defining class
* `$classCanonicalName` will be replaced by the canonical name of the method's defining class
* `$classTypeName` will be replaced by the type name of the method's defining class
* `$packageName` will be replaced by the package where the method is
* `$name` will be replaced by the name of the method
* `$typeClass` will be replaced by the return type of the method
* `$exceptions` will be replaced by the comma separated values of the exception types the method throws
* `$parameterTypes` will be replaced by the comma separated parameter types
* `$parameterCount` will be replaced by the number of the parameters in decimal format
* `$modifiers` will be replaced by the modifiers list of the method


These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

[source]
----
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
{java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
----

will result the output

[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

publicMethodMacro::evaluate(Input,Processor)
----


[[snip:update]]
==== xxiii. `snip:update`

This macro can be used to automatically copy the content of the snippets into the `snip` macros.
That way the Jamal source will contain an updated value of the snippet helping the navigation in the Jamal source file.

The result of the macro is an empty string, and it has no side effect inside the macro processor.
When it does, however, is that it alters the file it was used in inserting the snippets into the comment part of the `snip` macro.
Its operation is done in three steps:

1. Reads the file into the memory.
2. It goes through all the lines and inserts the content of the snippet into the comment part of the `snip` macros.
If there is already a comment there, then it gets deleted and replaced.
3. Writes the altered content into the original file updating it.

This macro alters the original file, therefore the use of it has to performed with great care.
Ensure that before executing Jamal, you save the original file, making a copy of it or committing into the git repository.

The `snip:update` macro does not perform Jamal syntax analysis.
To use this macro successfully you have to follow the extra rules:

* The `{@snip id...` macro should start on a new line.
There may be spaces before the macro.
There must not be a comment on the same line following the snipped identifier.
You can put a few non-space character after the snippet identifier in case you want to exclude a snippet use from the update.

* The `snip` macro matching macro closing string has to be on a separate line.
There may be spaces before and after the closing string, but nothing else.

The update macro can be customized.
If the macros `start` and/or `stop` are defined, then their value will be used as regular expression to find the start, and the end of the snippet content insertion points.
The default value for `start` is

    ^\s*\Q{\E\s*(?:#|@)\s*snip\s+([$_:a-zA-Z][$_:a-zA-Z0-9]*)\s*$

When this pattern is calculated, the current macro opening string is used instead of `{`.
The `stop` string is

    ^\s*\Q}\E\s*$

When this pattern is calculated, the current macro closing string is used instead of `}`.

(The `\Q` and `\E` escape sequences in Java regular expressions denote escaping, so that the characters between are matched literally.)

It is also possible to define a `head` and `tail` macro.
The content of the `head` macro will be copied in front of the inserted snippet.
The content of the `tail` macro will be copied after the inserted snippet.
It can be used to insert, for example asciidoc

   [source]
   ----

header and

   ----

footer when the snippets are code samples in an asciidoc file.

