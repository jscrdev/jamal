== Jamal Snippet Handling Macros
Last updated: 2021-01-23 13:50:49


Snippet handling macros help you to automatically include information from program source code into the documentation.

When you document an application there is a lot of information that changes by the change of the source code.
These changes have to be followed in the documentation.
Some changes need manual editing, some change can be automated.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
This change of the documentation can hardly be automated.
When some literal parameter also used in the document changes then the documentation can automatically be updated.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</dependency>
----

What you see in the `README.adoc` file is the actual version number converted from the `README.adoc.jam`.
The original file however, contains

[source,xml]
----
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed the snippets will automatically contain the actual text from the source code.
This way it is easier to keep your documentation up to date.

=== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip:collect,`snip:collect`>>
.. <<snip:properties,`snip:properties`>>
.. <<snip:xml,`snip:xml`>>
.. <<snip:define,`snip:define`>>
.. <<snip:clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<trimLines,`trimLines`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter:define,`counter:define`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<snip:update,`snip:update`>>




[[usage]]
=== 1. Usage

If you are using Jamal programmatically or from Maven then the dependency you have add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java` therefore they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
=== 2. Macros

[[snip:collect]]
==== i. `snip:collect`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect fileName}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file then the macro will collect the snippets from that single file.
If the `fileName` is a directory then the macro will collect the snippets from the files that are in that directory and from directories beneath recursively.

A snippet in a file is aseries of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the endling line.

The regular expression contains a collection group, which will be used as the name of the snippet.
For example the code



[source]
----
// snippet sample
public class Sample implements Macro {

    @Override
    public String evaluate(Input in, Processor processor) throws BadSyntax {
        String result = in.toString()
            .replaceAll("^\\n+","")
            .replaceAll("\\n+$","");
        return result;
    }
}
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The snippet start and end matching regular expression can be redefined.
If the user defined macro `start` is defined, then the value of it will be used as snippet start matching regular expression.
If the user defined macro `stop` is defined, then the value of it will be used as snippet end matching regular expression.

The collection of the files can also be controlled using user defined macros.
The macro `include` may define a regular expression as well as `exclude`.
When they are defined only the files that match the regular expression defined by `include` and do not match by `exclude` are collected.

It is enough if the regular expressions match a part of the lines or file name.

The user defined macros may be defined inside the `collect` macro.
This is the recommended practice.
For example, the test file

[source]
----
{#snip:collect . {@define exclude=2}}
First snippet {@snip first_snippet}
2. snippet {@snip second_snippet}

Next file
{@try!
First snippet {@snip second_file_first$snippet}
Second snippet {@snip seconda_snippet_uniconde}
}
and this is the end
----

excludes any file that contains the character `2` in its name.

[[snip:properties]]
==== ii. `snip:properties`

This macro will load properties from a "properties" file or from an "xml" file.
The names of the properties will become the names of the snippets and the values the values of the snippets.

For example, the sample

[source]
----
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
----


will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
a=letter a
b=    letter b
c = letter c
----

and thus using the `snip` macro, like

[source]
----
{@snip a}
----

will result



[source]
----
letter a

----


If the extension of the file is `.xml` then the properties will be loaded as XML format properties.
For example the same properties file in xml format looks like the following:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <comment>Application Configuration</comment>
    <entry key="a">letter a</entry>
    <entry key="b">letter b</entry>
    <entry key="c">letter c</entry>
</properties>
----

[[snip:xml]]
==== iii. `snip:xml`

This macro loads an XML file and assigns it to a "user defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

The defined `macroName` macro can be used as an ordinary user defined macro that accepts one argument.
This user defined macro evaluates in a special way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.

For example this document contains the following macros at the start:

[source]
----
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
----

The result is:

[source]
----
...
<version>1.5.4-SNAPSHOT</version>
...

----


which is the current version of the project as read from the `pom.xml` file.

[[snip:define]]
==== iv. `snip:define`

This macro can be used to define a snippet.
Snippets are usually collected from project files but it is also possible to defined them via the macro `snip:define`.
For example,

[source]
----
{@snip:define mySnippet=
This is the snippet, which is defined inside the file and not collected from an external file
}
{@snip mySnippet
is used here and then the rest of the text is ignored}
----

will result



[source]
----
This is the snippet, which is defined inside the file and not collected from an external file

----


[[snip:clear]]
==== v. `snip:clear`

Calling ths macro deletes all collected snippets from the memory.
The result of the macro is an empty string.

[[snip]]
==== vi. `snip`

The `snip` macro should have one argument, which should be the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip snipped_id comment}
----

is replaced by the content of the snippet named `snipped_id`.
The macro reads the ID from the input and it purposefully ignores the rest of the input.
The reason to have the rest of the input as comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code but the same time it is not a problem if the copy gets outdated.
The output fetched the content from the actual value of the snippet.

[[trimLines]]
==== vii. `trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When a code fragment is included into the documentation as a snippet the lines may have extra spaces at the start.
That is when the fragment comes from a code part that is somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
This way the code formatting remains the same as in the source code but the code sample will be aligned to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

[source]
----
 
{@trimLines
   k
      a
     b
    c
}
----

will result

[source]
----
 
k
   a
  b
 c


----


The macro can also delete the empty lines from the start and from the end of its input in case the option `trimVertical` is set.
For example

[source]
----
 
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
----

will result

[source]
----
 
k
 a
 b
c


----


[[numberLines]]
==== viii. `numberLines`

This macro can put numbers in front of the lines, sequetially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default the numbering of the lines start with one and every line gets the next number.
For example

[source]
----
{@numberLines this is the first line
this is the second line
  this is the third line
}
----

will result

[source]
----
1. this is the first line
2. this is the second line
3.   this is the third line

----


The number will be inserted with a `.` (dot) after the number and a space.

The user defined macros `start`, `step` and `format` can define different start value, step value and format for the numbers.
For example

[source]
----
{#numberLines {@define start=3}{@define step=2}{@define format= %03d:: }
this is the first line
this is the second line
this is the third line
}
----

will result

[source]
----
003:: this is the first line
005:: this is the second line
007:: this is the third line

----


The formatting will be used in the method `String::format`.
Any illegal formatting will result an error.

[[killLines]]
==== ix. `killLines`

This macro deletes selected lines from its input.

The format of the macro is

[source]
----
{@killLines

 ...

}
----

By default, the lines, which contain only spaces are deleted.
The user defined macro `pattern` may define a regular expression that can be used to select the lines.

For example:

[source]
----
{#killLines {@define pattern=^\s*//}
/* this stays */
// this is some C code that we want to list without the
      // single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
----

creates the output

[source]
----
/* this stays */

#define VERSION 1.0 //this line also stays put
int j = 15;

----


[[skipLines]]
==== x. `skipLines`

This macro can be used to skip lines from the snippet.
It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip` then the line, and the following lines are deleted from the output until a line matching `endSkip` is matched.
The lines that match the regular expressions are also deleted.

For example,

[source]
----
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines

----


You can also define the regular expressions defining the user defined macros `skip` and `endSkip`.
For example,

[source]
----
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines

----


It is not an error if there is no line matching the `endSkip`.
In that case all lines starting with the line matching the `skip` will be removed from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip` then any further `skip` is ignored until an `endSkip` is found.

[[replace]]
==== xi. `replace`

The macro `replace` replaces strings to other strings in its input.
 The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It uses the first argument as the input and then every following argument pairs as search and replace strings.
For example:

[source]
----
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
----

will result:

[source]
----
the pear has fallen off the bush

----


If the option `regex` is active then the search string are treated as regular expressions and the replace strings may also contain replacement parts.
For example,

[source]
----
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
----

will result the same output

[source]
----
the pear has fallen off the bush

----

but this time the replace used regular expression substitution.

[[replaceLines]]
==== xii. `replaceLines`

This macro replaces strings in the input.
It works similarly to the macro <<replace,`replace`>>.
The difference is that the replace

* is always based on regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the end or at the end of the line.
For example,

[source]
----
{@define replace=/^\s+\*\s+//}
{@replaceLines
 * this can be a snippet content
 * which was collected
 * from a Java or C program comment
}
----

will result

[source]
----
this can be a snippet content
which was collected
from a Java or C program comment

----


The search regular expressions, and the replacement strings have to be defined in the user defined macro `replace`.
This macro can be defined inside the `replaceLines` macro.
The macro scans the value of the user defined macro `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

[[counter:define]]
==== xiii. `counter:define`

This macro defines a counter.
The counter can be used like a parameterless user defined macro that returns the formatted actual value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define identifier}
----

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

[source]
----
{@counter:define c} {c} {c} {c}
----

will result

[source]
----
1 2 3

----


You can define the start, and the step value for the counter as well as the format.
For example,

[source]
----
{#counter:define c{@define start=2}{@define step=17}} {c} {c} {c}
----

will result

[source]
----
2 19 36

----


The format can contain the usual `String.format` formattings.
In addition to that it can also contain one of the `$alpha`, `$ALPHA`, `$roman` or `$ROMAN` literals.

* `$alpha` will be replaced by `a`, `b`, ... , `z` for 1, 2, ... , 26 counter values.
* `$ALPHA` will be replaced by `A`, `B`, ... , `Z` for 1, 2, ... , 26 counter values.
* `$roman` will be replaced by the lower case roman numeral format for 1, 2, ... , 3999 counter values.
* `$ROMAN` will be replaced by the upper case roman numeral format for 1, 2, ... , 3999 counter values.

It is an error

* if either `$alpha` or `$ALPHA` is used in the format, and the value is zero, negative, or larger than 26, or
* if either `$roman` or `$ROMAN` is used in the format, and the value is zero, negative, or larger than 3999.

Examples:

[source]
----
{#counter:define cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
----

The output will be


[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.

----


[[listDir]]
==== xiv. `listDir`

This macro list the files in a directory and then returns the comma separated list of the formatted files.
The format of the macro is:

[source]
----
{@listDir directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
For example,

[source]
----
{#for macroJavaFile in ({@listDir ./src/main/java/javax0/jamal/})=
 - macroJavaFile}
----

will result

[source]
----
- src/main/java/javax0/jamal
- src/main/java/javax0/jamal/snippet
- src/main/java/javax0/jamal/snippet/Snip.java
- src/main/java/javax0/jamal/snippet/Case.java
- src/main/java/javax0/jamal/snippet/NumberLines.java
- src/main/java/javax0/jamal/snippet/DateMacro.java
- src/main/java/javax0/jamal/snippet/Format.java
- src/main/java/javax0/jamal/snippet/Update.java
- src/main/java/javax0/jamal/snippet/Collect.java
- src/main/java/javax0/jamal/snippet/TrimLines.java
- src/main/java/javax0/jamal/snippet/Replace.java
- src/main/java/javax0/jamal/snippet/SnipXml.java
- src/main/java/javax0/jamal/snippet/Counter.java
- src/main/java/javax0/jamal/snippet/Clear.java
- src/main/java/javax0/jamal/snippet/KillLines.java
- src/main/java/javax0/jamal/snippet/SnippetStore.java
- src/main/java/javax0/jamal/snippet/ListDir.java
- src/main/java/javax0/jamal/snippet/XmlFormat.java
- src/main/java/javax0/jamal/snippet/SnipProperties.java
- src/main/java/javax0/jamal/snippet/CounterMacro.java
- src/main/java/javax0/jamal/snippet/XmlDocument.java
- src/main/java/javax0/jamal/snippet/Java.java
- src/main/java/javax0/jamal/snippet/ReplaceLines.java
- src/main/java/javax0/jamal/snippet/SkipLines.java
- src/main/java/javax0/jamal/snippet/Snippet.java

----


The listing of the files is recursive and is unlimited.
The limit of the recursion can be limited defining the user defined macro `maxDepth`.
The same listing limited to 1 depth (non-recursive) is the following

[source]
----
{#for macroJavaFile in ({#listDir ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
----

will result

[source]
----
- src/main/java/javax0/jamal
- src/main/java/javax0/jamal/snippet

----


The default formatting for the list of the files is the name of the file.
Theuser defined macro `format` can define other formats.
This format can contain placeholder and these will be replaced with actual parameters of the files.
When used in a multi variable for loop then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders:

%}


* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.


For example,

[source]
----
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
----

will result

[source]
----
- jamal: 96 bytes
- snippet: 800 bytes
- Snip.java: 606 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,199 bytes
- DateMacro.java: 659 bytes
- Format.java: 2,557 bytes
- Update.java: 3,509 bytes
- Collect.java: 4,587 bytes
- TrimLines.java: 2,811 bytes
- Replace.java: 1,716 bytes
- SnipXml.java: 1,511 bytes
- Counter.java: 3,323 bytes
- Clear.java: 451 bytes
- KillLines.java: 1,525 bytes
- SnippetStore.java: 3,045 bytes
- ListDir.java: 3,917 bytes
- XmlFormat.java: 2,458 bytes
- SnipProperties.java: 1,485 bytes
- CounterMacro.java: 1,870 bytes
- XmlDocument.java: 2,038 bytes
- Java.java: 4,691 bytes
- ReplaceLines.java: 2,255 bytes
- SkipLines.java: 2,100 bytes
- Snippet.java: 1,059 bytes

----



If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for colelction the files will follow symlinks.

[[xmlFormat]]
==== xv. `xmlFormat`

The macro `xmlFormat` interprets the input as an XML document and the result is the document formatted.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.5.4-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</project>

----


The default tabulation size is four.
You can alter it defining the user defined macro `tabsize`.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.5.4-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<name>jamal snippet</name>
<packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId>
<artifactId>jamal-snippet</artifactId>
<version>1.5.4-SNAPSHOT</version>
</project>

----


As you can see there is no tabulation in this case.

[[date]]
==== xvi. `date`

This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

[source]
----
{@date yyyy-MM-dd HH:mm:ss}
----

wll result the output

[source]
----
2021-01-23 13:50:49

----


[[format]]
==== xvii. `format`

The macro `format` can be used to format the arguments.
 The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal all these argument are strings.
Since the parameters to the underlying `String::format` method are not only strings they can be converted.
If any of the parameters starts with a `(xxx)` string then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be


* `int`, the conversion will call Integer::parseInt.
* `long`, the conversion will call Long::parseLong.
* `double`, the conversion will call Double::parseDouble.
* `float`, the conversion will call Float::parseFloat.
* `boolean`, the conversion will call Boolean::parseBoolean.
* `short`, the conversion will call Short::parseShort.
* `byte`, the conversion will call Byte::parseByte.
* `char`, the conversion will fetch the first character of the parameter.

Examples:

[source]
----
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
----

wll result the output

[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437

----


[[Java]]
==== xviii. Java Macros

[[java:class]]
===== `java:class`


The macro `java:class` checks that the parameter is a valid Java class and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the class mentioned in the documentation is still there, it was not deleted or renamed.

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the user defined macro `classFormat`.
For example:

[source]
----
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
----

wll result the output

[source]
----
The class that implements the macro `java:class` is
ClassMacro.

----


The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:


* `$simpleName` will be replaced by the result of calling `getSimpleName()`
* `$name` will be replaced by the result of calling `getName()`
* `$canonicalName` will be replaced by the result of calling `getCanonicalName()`
* `$packageName` will be replaced by the result of calling `getPackageName()`
* `$typeName` will be replaced by the result of calling `getTypeName()`


For example

[source]
----
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
----

wll result the output

[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.

----


It is not recommended to overuse the format string.
Do not include verbatim text into the format string.
Choose a format string how you want to refer to the classes and use it globally in the document.

[[java:method]]
===== `java:method`


The macro `java:method` checks that the parameter is a valid Java method and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the method mentioned in the documentation is still there, it was not deleted or renamed.

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the user defined macro `methodFormat`.
For example:

[source]
----
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
----

wll result the output

[source]
----
evaluate

----


The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:


* `$classSimpleName` will be replaced by the simple name of the method's defining class
* `$className` will be replaced by the name of the of the method's defining class
* `$classCanonicalName` will be replaced by the canonical name of the method's defining class
* `$classTypeName` will be replaced by the type name of the methodC
* `$packageName` will be replaced by the package where the method is
* `$name` will be replaced by the name of the method
* `$typeClass` will be replaced by the return type of the method
* `$exceptions` will be replaced by the comma separated values of the exception types the method throws
* `$parameterTypes` will be replaced by the comma separated parameter types
* `$parameterCount` will be replaced by the number of the parameters in decimal format
* `$modifiers` will be replaced by the modifiers list of the method


These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

[source]
----
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
 {java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
----

wll result the output

[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

public MethodMacro::evaluate(Input,Processor)

----


[[snip:update]]
==== xix. `snip:update`

This macro can be used to automatically copy the content of the snippets into the `snip` macros.
That way the Jamal source will contain an updated value of the snippet helping the navigation in the Jamal source file.

The result of the macro is empty string, and it has no side effect inside the macro processor.
Whe it does, however is that it alters the file it was used in inserting the snippets into the comment part of the `snip` macro.
Its operation is done in three steps:

1. Reads the file into the memory.
2. It goes through all the lines and inserts the content of the snippet into the comment part of the `snip` macros.
If there is already a comment there then it gets deleted and replaced.
3. Writes the altered content into the original file updating it.

This macro alters the original file, therefore the use of it has to performed with great care.
Ensure that before executing Jamal you save the original file, making a copy of it or committing into the git repository.

The `snip:update` macro does not perfom Jamal syntax analysis.
To use this macro successfully you have to follow the extra rules:

* The `{@snip id...` macro should start on a new line.
There may be spaces before the macro.
There must not be a comment on the same line following the snipped identifier.
You can put a few non-space character after the snippet identifier in case you want to exclude a snippet use from the update.

* The `snip` macro matching macro closing string has to be on a separate line.
There may be spaces before and after the closing string, but nothing else.

The update macro can be customized.
If the macros `start` and/or `stop` are defined then their value will be used as regular expression to find the start and the end of the snippet content insertion points.
The default value for `start` is

    ^\s*\Q{\E\s*(?:#|@)\s*snip\s+([$_:a-zA-Z][$_:a-zA-Z0-9]*)\s*$

When this pattern is calculated the current macro opening string is used instead of `{`.
The `stop` string is

    ^\s*\Q}\E\s*$

When this pattern is calculated the current macro closing string is used instead of `}`.

(The `\Q` and `\E` escape sequences in Java regular expressions denote escaping, so that the characters between are matched literally.)

It is also possible to define a `head` and `tail` macro.
The content of the `head` macro will be copied in front of the inserted snippet.
The content of the `tail` macro will be copied after the inserted snippet.
It can be used to insert, for example asciidoc

   [source]
   ----

header and

   ----

footer when the snippets are code samples in an asciidoc file.

