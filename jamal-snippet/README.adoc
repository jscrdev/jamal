== Jamal Snippet Handling Macros

Snippet handling macros help you to automatically include information from program source code into the documentation.

When you document an application there is a lot of information that changes by the change of the source code.
These changes have to be followed in the documentation.
Some changes need manual editing, some change can be automated.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
This change of the documentation can hardly be automated.
When some literal parameter also used in the document changes then the documentation can automatically be updated.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</dependency>
----

What you see in the `README.adoc` file converted from the `README.adoc.jam` is the actual version number.
The original file however, contains

[source,xml]
----
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed the snippets will automatically contain the actual text from the source code.
This way it is easier to keep your documentation up to date.

=== Usage

If you are using Jamal programmatically or from Maven then the dependency you have add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java` therefore they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

=== Macros

==== `snip:collect`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect fileName}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file then the macro will collect the snippets from that single file.
If the `fileName` is a directory then the macro will collect the snippets from the files that are in that directory and from directories beneath recursively.

A snippet in a file is aseries of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the endling line.

The regular expression contains a collection group, which will be used as the name of the snippet.
For example the code



[source]
----
// snippet sample
public class Sample implements Macro {

    @Override
    public String evaluate(Input in, Processor processor) throws BadSyntax {
        String result = in.toString()
            .replaceAll("^\\n+","")
            .replaceAll("\\n+$","");
        return result;
    }
}
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The snippet start and end matching regular expression can be redefined.
If the user defined macro `start` is defined, then the value of it will be used as snippet start matching regular expression.
If the user defined macro `stop` is defined, then the value of it will be used as snippet end matching regular expression.

The collection of the files can also be controlled using user defined macros.
The macro `include` may define a regular expression as well as `exclude`.
When they are defined only the files that match the regular expression defined by `include` and do not match by `exclude` are collected.

It is enough if the regular expressions match a part of the lines or file name.

The user defined macros may be defined inside the `collect` macro.
This is the recommended practice.
For example, the test file

[source]
----
{#snip:collect . {@define exclude=2}}
First snippet {@snip first_snippet}
2. snippet {@snip second_snippet}

Next file
{@try!
First snippet {@snip second_file_first$snippet}
Second snippet {@snip seconda_snippet_uniconde}
}
and this is the end
----

excludes any file that contains the character `2` in its name.

[[snip:define]]
==== `snip:define`

This macro can be used to define a snippet.
Snippets are usually collected from project files but it is also possible to defined them via the macro `snip:define`.
For example,

[source]
----
{@snip:define mySnippet=
This is the snippet, which is defined inside the file and not collected from an external file
}
{@snip mySnippet
is used here and then the rest of the text is ignored}
----

will result

[source]
----
This is the snippet, which is defined inside the file and not collected from an external file

----


[[clear]]
==== `snip:clear`

Calling ths macro deletes all collected snippets from the memory.
The result of the macro is an empty string.

[[snip]]
==== `snip`

The `snip` macro should have one argument, which should be the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip snipped_id comment}
----

is replaced by the content of the snippet named `snipped_id`.
The macro reads the ID from the input and it purposefully ignores the rest of the input.
The reason to have the rest of the input as comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code but the same time it is not a problem if the copy gets outdated.
The output fetched the content from the actual value of the snippet.

[[properties]]
==== `snip:properties`

This macro will load properties from a "properties" file or from an "xml" file.
The names of the properties will become the names of the snippets and the values the values of the snippets.

For example the samepl

[source]
----
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
----


will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
a=letter a
b=    letter b
c = letter c
----

and thus using the `snip` macro, like

[source]
----
{@snip a}
----

will result

[source]
----
letter a

----


If the extension of the file is `.xml` then the properties will be loaded as XML format properties.
For example the same properties file in xml format looks like the following:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <comment>Application Configuration</comment>
    <entry key="a">letter a</entry>
    <entry key="b">letter b</entry>
    <entry key="c">letter c</entry>
</properties>
----

[[xml]]
==== `snip:xml`

This macro loads an XML file and assigns it to a "user defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

The defined `macroName` macro can be used as an ordinary user defined macro that accepts one argument.
This user defined macro evaluates in a special way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.

For example this document contains the following macros at the start:

[source]
----
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
         <version>{VERSION}</version>
...
----

The result is:

[source]
----
...
         <version>1.5.4-SNAPSHOT</version>
...

----


which is the current version of the project as read from the `pom.xml` file.

[[trimLines]]
==== `trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When a code fragment is included into the documentation as a snippet the lines may have extra spaces at the start.
That is when the fragment comes from a code part that is somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
This way the code formatting remains the same as in the source code but the code sample will be aligned to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

[source]
----
 
{@trimLines
   k
      a
     b
    c
}
----

will result

[source]
----
 
k
   a
  b
 c


----


The macro can also delete the empty lines from the start and from the end of its input in case the option `trimVertical` is set.
For example

[source]
----
 
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
----

will result

[source]
----
 
k
 a
 b
c


----


[[numberLines]]
==== `numberLines`

This macro can put numbers in front of the lines, sequetially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default the numbering of the lines start with one and every line gets the next number.
For example

[source]
----
{@numberLines this is the first line
this is the second line
  this is the third line
}
----

will result

[source]
----
1. this is the first line
2. this is the second line
3.   this is the third line

----


The number will be inserted with a `.` (dot) after the number and a space.

The user defined macros `start`, `step` and `format` can define different start value, step value and format for the numbers.
For example

[source]
----
{#numberLines {@define start=3}{@define step=2}{@define format= %03d:: }
this is the first line
this is the second line
this is the third line
}
----

will result

[source]
----
003:: this is the first line
005:: this is the second line
007:: this is the third line

----


The formatting will be used in the method `String::format`.
Any illegal formatting will result an error.

[[killLines]]
==== `killLines`

This macro deletes selected lines from its input.

The format of the macro is

[source]
----
{@killLines

 ...

}
----

By default, the lines, which contain only spaces are deleted.
The user defined macro `pattern` may define a regular expression that can be used to select the lines.

For example:

[source]
----
{#killLines {@define pattern=^\s*//}
/* this stays */
// this is some C code that we want to list without the
      // single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
----

creates the output

[source]
----
/* this stays */

#define VERSION 1.0 //this line also stays put
int j = 15;

----


[[skipLines]]
==== `skipLines`

This macro can be used to skip lines from the snippet.
It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip` then the line, and the following lines are deleted from the output until a line matching `endSkip` is matched.
The lines that match the regular expressions are also deleted.

For example,

[source]
----
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines

----


You can also define the regular expressions defining the user defined macros `skip` and `endSkip`.
For example,

[source]
----
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}
----

will result

[source]
----
this line is there
there can be more lines

----


It is not an error if there is no line matching the `endSkip`.
In that case all lines starting with the line matching the `skip` will be removed from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip` then any further `skip` is ignored until an `endSkip` is found.

[[replace]]
==== `replace`

The macro `replace` replaces strings to other strings in its input.
The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It uses the first argument as the input and then every following argument pairs as search and replace strings.
For example:

[source]
----
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
----

will result:

[source]
----
the pear has fallen off the bush

----


If the option `regex` is active then the search string are treated as regular expressions and the replace strings may also contain replacement parts.
For example,

[source]
----
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
----

will result the same output

[source]
----
the pear has fallen off the bush

----


but this time the replace used regular expression substitution.

[[replaceLines]]
==== `replaceLines`

This macro replaces strings in the input.
It works similarly to the macro <<replace,`replace`>>.
The difference is that the replace

* is always based on regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the end or at the end of the line.
For example,

[source]
----
{@define replace=/^\s+\*\s+//}
{@replaceLines
 * this can be a snippet content
 * which was collected
 * from a Java or C program comment
}
----

will result

[source]
----
this can be a snippet content
which was collected
from a Java or C program comment

----


The search regular expressions, and the replacement strings have to be defined in the user defined macro `replace`.
This maco can be defined inside the `replaceLines` macro.
The macro scans the value of the user defined macro `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

[[snip:update]]
==== `snip:update`

This macro can be used to automatically copy the content of the snippets into the `snip` macros.
That way the Jamal source will contain an updated value of the snippet helping the navigation in the Jamal source file.

The result of the macro is empty string, and it has no side effect inside the macro processor.
Whe it does, however is that it alters the file it was used in inserting the snippets into the comment part of the `snip` macro.
Its operation is done in three steps:

1. Reads the file into the memory.
2. It goes through all the lines and inserts the content of the snippet into the comment part of the `snip` macros.
   If there is already a comment there then it gets deleted and replaced.
3. Writes the altered content into the original file updating it.

This macro alters the original file, therefore the use of it has to performed with great care.
Ensure that before executing Jamal you save the original file, making a copy of it or committing into the git repository.

The `snip:update` macro does not perfom Jamal syntax analysis.
To use this macro successfully you have to follow the extra rules:

* The `{@snip id...` macro should start on a new line.
  There may be spaces before the macro.
  There must not be a comment on the same line following the snipped identifier.
  You can put a few non-space character after the snippet identifier in case you want to exclude a snippet use from the update.

* The `snip` macro matching macro closing string has to be on a separate line.
  There may be spaces before and after the closing string, but nothing else.

The update macro can be customized.
If the macros `start` and/or `stop` are defined then their value will be used as regular expression to find the start and the end of the snippet content insertion points.
The default value for `start` is

    ^\s*\Q{\E\s*(?:#|@)\s*snip\s+([$_:a-zA-Z][$_:a-zA-Z0-9]*)\s*$

When this pattern is calculated the current macro opening string is used instead of `{`.
The `stop` string is

    ^\s*\Q}\E\s*$

When this pattern is calculated the current macro closing string is used instead of `}`.

(The `\Q` and `\E` escape sequences in Java regular expressions denote escaping, so that the characters between are matched literally.)

It is also possible to define a `head` and `tail` macro.
The content of the `head` macro will be copied in front of the inserted snippet.
The content of the `tail` macro will be copied after the inserted snippet.
It can be used to insert, for example asciidoc

   [source]
   ----

header and

   ----

footer when the snippets are code samples in an asciidoc file.

[[xmlFormat]]
==== `xmlFormat`

The macro `xmlFormat` interprets the input as an XML document and the result is the document formatted.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.5.4-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.5.4-SNAPSHOT</version>
</project>

----


The default tabulation size is four.
You can alter it defining the user defined macro `tabsize`.
For example,

[source]
----
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>1.5.4-SNAPSHOT</version>
</project>
}
----

will result

[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<name>jamal snippet</name>
<packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId>
<artifactId>jamal-snippet</artifactId>
<version>1.5.4-SNAPSHOT</version>
</project>

----
