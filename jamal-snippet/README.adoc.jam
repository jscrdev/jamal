== Jamal Snippet Handling Macros
{%@import ../readmemacros.jim%}\
{%@snip:collect src/main/java/%}\
{%#define lastUpdated={%@date yyyy-MM-dd HH:mm:ss%}%}\
{%#snip:define lastUpdated={%lastUpdated%}%}\

{%@define standardInput= The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.%}

Snippet handling macros help you to automatically include information from program source code into the documentation.

When you document an application there is a lot of information that changes by the change of the source code.
These changes have to be followed in the documentation.
Some changes need manual editing, some change can be automated.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
This change of the documentation can hardly be automated.
When some literal parameter also used in the document changes then the documentation can automatically be updated.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

What you see in the `README.adoc` file is the actual version number converted from the `README.adoc.jam`.
The original file however, contains

[source,xml]
----
{{%@ident%}%@snip:xml pom=pom.xml%{%@ident%}}\
{{%@ident%}%#define VERSION={{%@ident%}%pom /project/version/text()%{%@ident%}}%{%@ident%}}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{{%@ident%}%VERSION%{%@ident%}}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed the snippets will automatically contain the actual text from the source code.
This way it is easier to keep your documentation up to date.

=== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip:collect,`snip:collect`>>
.. <<snip:properties,`snip:properties`>>
.. <<snip:xml,`snip:xml`>>
.. <<snip:define,`snip:define`>>
.. <<snip:clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<trimLines,`trimLines`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter:define,`counter:define`>>
.. <<reflow,`reflow`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<file,`file`>>
.. <<directory,`directory`>>
.. <<Java,Java Macros>>
.. <<snip:update,`snip:update`>>

{%#counter:define chapter {%@define format=%d. %}%}
{%#counter:define macroChapter {%@define format=$roman. %}%}

[[usage]]
=== {%chapter%}Usage

If you are using Jamal programmatically or from Maven then the dependency you have add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java` therefore they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
=== {%chapter%}Macros

[[snip:collect]]
==== {%macroChapter%}`snip:collect`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect fileName}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file then the macro will collect the snippets from that single file.
If the `fileName` is a directory then the macro will collect the snippets from the files that are in that directory and from directories beneath recursively.

A snippet in a file is a series of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the endling line.

[NOTE]
====
The definition and matching criteria of the start and the end of the snippet is very liberal.
The reason for that is to ease in recognizing these in different files.
The regular expressions will find snippet start and snippet ends in Java files, in XML, in Perl or Python code.
Essentially you should not have a problem signaling the start and the end of the snippet in any program code that allows you to write some form of a comment.

The disadvantage of this liberal definition is that sometimes it finds lines that accidentally contain the word snippet.
If you look at the source code in the file {%@file src/main/java/javax0/Jamal/snippet/TrimLines.java%} you can see examples.
The comment mentions snippets, and there is a word eligible to be an identifier after `snippet`, and the parsing thinks that this is a snippet start.
Eventually, there is no `end snippet` on the lines following it, which is an error the snippet collection process recognizes.
And still, you do not receive an error message.

That is because the collection process only recognizes this error but does not throw an exception.
The exception is thrown only when you want to use the `snip` macro for an unterminated snippet.

The possible situation may even be more complicated because the accidental word following `snippet` in a comment may also be used in other files as a snippet identifier.
The collector, sooner or later, will find that definition, and it will assume that the one with the error was just an accidental comment and replaces the old with the correct, error free snippet.
It is still okay when the snippet collection finds these two snippets in the opposite order.
If there is already a correct, error free snippet collected and the collection finds an erroneous one of the same name, it ignores that.

This way, the collection and the use of the snippets ignores the accidental snippet definitions, but at the same time, it can detect the mal-formed snippets.
====

The regular expression contains a collection group, which will be used as the name of the snippet.
For example the code

{%@snip:collect src/test/java/javax0/jamal/documentation/Sample.java%}

[source]
----
// snippet sample
{%@snip sample%}\
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The snippet start and end matching regular expression can be redefined.
If the user defined macro `start` is defined, then the value of it will be used as snippet start matching regular expression.
If the user defined macro `stop` is defined, then the value of it will be used as snippet end matching regular expression.

The collection of the files can also be controlled using user defined macros.
The macro `include` may define a regular expression as well as `exclude`.
When they are defined only the files that match the regular expression defined by `include` and do not match by `exclude` are collected.

It is enough if the regular expressions match a part of the lines or file name.

The user defined macros may be defined inside the `collect` macro.
This is the recommended practice.
For example, the test file

[source]
----
{%@include res:javax0/jamal/snippet/test3.jam%}
----

excludes any file that contains the character `2` in its name.

[[snip:properties]]
==== {%macroChapter%}`snip:properties`

This macro will load properties from a "properties" file or from an "xml" file.
The names of the properties will become the names of the snippets and the values the values of the snippets.

For example, the sample

{%sample/
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
%}

{%#comment this output is evaluated because this is when themacro in the sample is evaluated
{%output%} but there is no output. The laster samples use the snippets that this macro evaluation
was reading from the properties file
%}\

will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
{%@include res:javax0/jamal/snippet/testproperties.properties%}
----

and thus using the `snip` macro, like

{%sample/
{@snip a}
%}

will result

{%#snip:define snipa={%output%}%}

{%@snip snipa
[source]
----
letter a

----
%}

If the extension of the file is `.xml` then the properties will be loaded as XML format properties.
For example the same properties file in xml format looks like the following:

[source,xml]
----
{%@include res:javax0/jamal/snippet/testproperties.xml%}
----

[[snip:xml]]
==== {%macroChapter%}`snip:xml`

This macro loads an XML file and assigns it to a "user defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

The defined `macroName` macro can be used as an ordinary user defined macro that accepts one argument.
This user defined macro evaluates in a special way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.

For example this document contains the following macros at the start:

{%sample/
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
%}

The result is:
{%#snip:define versionSnippet={%output%}%}\

{%@snip versionSnippet
[source]
----
...
<version>1.7.1</version>
...

----
%}

which is the current version of the project as read from the `pom.xml` file.

[[snip:define]]
==== {%macroChapter%}`snip:define`

This macro can be used to define a snippet.
Snippets are usually collected from project files but it is also possible to defined them via the macro `snip:define`.
For example,

{%sample/
{@snip:define mySnippet=
This is the snippet, which is defined inside the file and not collected from an external file
}
{@snip mySnippet
is used here and then the rest of the text is ignored}
%}

will result

{%#snip:define mySnippet={%output%}%}

{%@snip mySnippet
[source]
----
This is the snippet, which is defined inside the file and not collected from an external file

----
%}

[[snip:clear]]
==== {%macroChapter%}`snip:clear`

Calling ths macro deletes all collected snippets from the memory.
The result of the macro is an empty string.

[[snip]]
==== {%macroChapter%}`snip`

The `snip` macro should have one argument, which should be the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip snipped_id comment}
----

is replaced by the content of the snippet named `snipped_id`.
The macro reads the ID from the input and it purposefully ignores the rest of the input.
The reason to have the rest of the input as comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code but the same time it is not a problem if the copy gets outdated.
The output fetched the content from the actual value of the snippet.

[[trimLines]]
==== {%macroChapter%}`trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When a code fragment is included into the documentation as a snippet the lines may have extra spaces at the start.
That is when the fragment comes from a code part that is somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
This way the code formatting remains the same as in the source code but the code sample will be aligned to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

{%untrimmedSample/
{@trimLines
   k
      a
     b
    c
}
%}

will result

{%untrimmedOutput%}

The macro can also delete the empty lines from the start and from the end of its input in case the option `trimVertical` is set.
For example

{%untrimmedSample/
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
%}

will result

{%untrimmedOutput%}

[[numberLines]]
==== {%macroChapter%}`numberLines`

This macro can put numbers in front of the lines, sequetially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default the numbering of the lines start with one and every line gets the next number.
For example

{%sample/
{@numberLines this is the first line
this is the second line
  this is the third line
}
%}

will result
{%#snip:define numberedLines1={%output%}%}\

{%@snip numberedLines1
[source]
----
1. this is the first line
2. this is the second line
3.   this is the third line

----
%}

The number will be inserted with a `.` (dot) after the number and a space.

The user defined macros `start`, `step` and `format` can define different start value, step value and format for the numbers.
For example

{%sample/
{#numberLines {@define start=3}{@define step=2}{@define format= %03d:: }
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines2={%output%}%}\

{%@snip numberedLines2
[source]
----
003:: this is the first line
005:: this is the second line
007:: this is the third line

----
%}

The formatting will be used in the method `String::format`.
Any illegal formatting will result an error.

[[killLines]]
==== {%macroChapter%}`killLines`

This macro deletes selected lines from its input.

The format of the macro is

[source]
----
{@killLines

 ...

}
----

By default, the lines, which contain only spaces are deleted.
The user defined macro `pattern` may define a regular expression that can be used to select the lines.

For example:

{%sample/
{#killLines {@define pattern=^\s*//}
/* this stays */
// this is some C code that we want to list without the
      // single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output
{%#snip:define killLines1={%output%}%}\

{%@snip killLines1
[source]
----
/* this stays */

#define VERSION 1.0 //this line also stays put
int j = 15;

----
%}

[[skipLines]]
==== {%macroChapter%}`skipLines`

This macro can be used to skip lines from the snippet.
It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip` then the line, and the following lines are deleted from the output until a line matching `endSkip` is matched.
The lines that match the regular expressions are also deleted.

For example,

{%sample/
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
%}

will result
{%#snip:define skipLines1={%output%}%}\

{%@snip skipLines1
[source]
----
this line is there
there can be more lines

----
%}

You can also define the regular expressions defining the user defined macros `skip` and `endSkip`.
For example,

{%sample/
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}%}

will result
{%#snip:define skipLines2={%output%}%}\

{%@snip skipLines2
[source]
----
this line is there
there can be more lines

----
%}

It is not an error if there is no line matching the `endSkip`.
In that case all lines starting with the line matching the `skip` will be removed from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip` then any further `skip` is ignored until an `endSkip` is found.

[[replace]]
==== {%macroChapter%}`replace`

The macro `replace` replaces strings to other strings in its input.
{%standardInput%}

It uses the first argument as the input and then every following argument pairs as search and replace strings.
For example:

{%sample/
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
%}

will result:
{%#snip:define replace1={%output%}%}\

{%@snip replace1
[source]
----
the pear has fallen off the bush

----
%}

If the option `regex` is active then the search string are treated as regular expressions and the replace strings may also contain replacement parts.
For example,

{%sample/
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
%}

will result the same output
{%#snip:define replace2={%output%}%}\

{%@snip replace2
[source]
----
the pear has fallen off the bush

----
%}
but this time the replace used regular expression substitution.

[[replaceLines]]
==== {%macroChapter%}`replaceLines`

This macro replaces strings in the input.
It works similarly to the macro <<replace,`replace`>>.
The difference is that the replace

* is always based on regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the start or at the end of the line.
For example,

{%sample/
{@define replace=/^\s+\*\s+//}
{@replaceLines
 * this can be a snippet content
 * which was collected
 * from a Java or C program comment
}
%}

will result
{%#snip:define replaceLines1={%output%}%}\

{%@snip replaceLines1
[source]
----
this can be a snippet content
which was collected
from a Java or C program comment

----
%}

The search regular expressions, and the replacement strings have to be defined in the user defined macro `replace`.
This macro can be defined inside the `replaceLines` macro.
The macro scans the value of the user defined macro `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

[[counter:define]]
==== {%macroChapter%}`counter:define`

This macro defines a counter.
The counter can be used like a parameterless user defined macro that returns the formatted actual value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define identifier}
----

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

{%sample/
{@counter:define c} {c} {c} {c}
%}

will result
{%#snip:define counter1=
{%output%}%}\

{%@snip counter1
[source]
----
1 2 3

----
%}

You can define the start, and the step value for the counter as well as the format.
For example,

{%sample/
{#counter:define c{@define start=2}{@define step=17}} {c} {c} {c}
%}

will result
{%#snip:define counter2=
{%output%}%}\

{%@snip counter2
[source]
----
2 19 36

----
%}

The format can contain the usual `String.format` formattings.
In addition to that it can also contain one of the `$alpha`, `$ALPHA`, `$roman` or `$ROMAN` literals.

{%@define alphaRomanReplace($format,$by,$number)={%@ident%}\
* `$format` will be replaced by $by for 1, 2, ... , $number counter values.%}\
{%alphaRomanReplace/$alpha/`a`, `b`, ... , `z`/26%}
{%alphaRomanReplace/$ALPHA/`A`, `B`, ... , `Z`/26%}
{%alphaRomanReplace/$roman/the lower case roman numeral format/3999%}
{%alphaRomanReplace/$ROMAN/the upper case roman numeral format/3999%}

It is an error
{%@define errorMessage($format,$number)={%@ident%}\
* if either `$format` or `{%@case:upper $format%}` is used in the format, and the value is zero, negative, or larger than $number%}
{%errorMessage /$alpha/26%}, or
{%errorMessage /$roman/3999%}.

Examples:

{%sample/
{#counter:define cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
%}

The output will be

{%#snip:define counter3=
{%output%}%}\

{%@snip counter3
[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.

----
%}

[[reflow]]
==== {%macroChapter%}`reflow`

This macro reflows the content of it.
The default behaviour is that the lines will be any long and the paragraph will be separated by double new-lines.

For example:

{%sample/
{@reflow the first line is comment, ignored
The
short
lines
will
be put into a single line.

Empty lines are paragraph limiters.




Multiple empty lines are
converted to one.}
%}

The output will be

{%#snip:define reflow1=
{%output%}%}\

{%@snip reflow1
[source]
----
The short lines will be put into a single line.

Empty lines are paragraph limiters.

Multiple empty lines are converted to one.

----
%}

If the user defined macro `width` specifies a positive integer number then it wil be used to limit the length of the lines.
For example

{%sample/
{@define width=1}
{@reflow the first line is comment, ignored
The
long
lines
will
be broken into words.

Empty lines are paragraph limiters.}
%}

The output will be

{%#snip:define reflow2=
{%output%}%}\

{%@snip reflow2
[source]
----
The
long
lines
will
be
broken
into
words.

Empty
lines
are
paragraph
limiters.

----
%}

Setting the `width` to any non-positive value will remove the limit from the line length.

[[listDir]]
==== {%macroChapter%}`listDir`

This macro list the files in a directory and then returns the comma separated list of the formatted files.
The format of the macro is:

[source]
----
{@listDir directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
For example,

{%sample/
{#for macroJavaFile in ({@listDir ./src/main/java/javax0/jamal/})=
 - macroJavaFile}
%}

will result
{%#snip:define listDir1=
{%output%}%}\

{%@snip listDir1
[source]
----
- ../jamal-snippet/src/main/java/javax0/jamal
- ../jamal-snippet/src/main/java/javax0/jamal/snippet
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Snip.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Case.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/NumberLines.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/DateMacro.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Format.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Update.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/FilesMacro.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Collect.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/TrimLines.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Replace.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/SnipXml.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Counter.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Clear.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/KillLines.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/SnippetStore.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/ListDir.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/XmlFormat.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/SnipProperties.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/CounterMacro.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/XmlDocument.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Java.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/ReplaceLines.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/SkipLines.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Reflow.java
- ../jamal-snippet/src/main/java/javax0/jamal/snippet/Snippet.java

----
%}

The listing of the files is recursive and is unlimited.
The limit of the recursion can be limited defining the user defined macro `maxDepth`.
The same listing limited to 1 depth (non-recursive) is the following

{%sample/
{#for macroJavaFile in ({#listDir ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
%}

will result
{%#snip:define listDir2=
{%output%}%}\

{%@snip listDir2
[source]
----
- ../jamal-snippet/src/main/java/javax0/jamal
- ../jamal-snippet/src/main/java/javax0/jamal/snippet

----
%}

The default formatting for the list of the files is the name of the file.
Theuser defined macro `format` can define other formats.
This format can contain placeholder and these will be replaced with actual parameters of the files.
When used in a multi variable for loop then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders:

{%#snip:define listDirFormats$formatted=
{%#replaceLines
{%@define replace =`\n`
^\s*"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTF
of the file.
TITF
string literal `true` if the file
FO
`false` otherwise.
%}
        {%#snip listDirFormats%}%}%}%}

{%@snip listDirFormats$formatted

* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.
%}

For example,

{%sample/
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
%}

will result
{%#snip:define listDir3=
{%output%}%}\

{%@snip listDir3
[source]
----
- jamal: 96 bytes
- snippet: 864 bytes
- Snip.java: 606 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,199 bytes
- DateMacro.java: 659 bytes
- Format.java: 993 bytes
- Update.java: 3,509 bytes
- FilesMacro.java: 4,465 bytes
- Collect.java: 5,030 bytes
- TrimLines.java: 2,810 bytes
- Replace.java: 1,686 bytes
- SnipXml.java: 1,511 bytes
- Counter.java: 3,323 bytes
- Clear.java: 451 bytes
- KillLines.java: 1,525 bytes
- SnippetStore.java: 6,571 bytes
- ListDir.java: 3,943 bytes
- XmlFormat.java: 3,290 bytes
- SnipProperties.java: 1,485 bytes
- CounterMacro.java: 1,870 bytes
- XmlDocument.java: 2,038 bytes
- Java.java: 5,806 bytes
- ReplaceLines.java: 2,575 bytes
- SkipLines.java: 2,100 bytes
- Reflow.java: 1,742 bytes
- Snippet.java: 1,088 bytes

----
%}


If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for colelction the files will follow symlinks.

[[xmlFormat]]
==== {%macroChapter%}`xmlFormat`

The macro `xmlFormat` interprets the input as an XML document if there is any, and the result is the document formatted.
If the input is empty or contains only spaces then it registers a post processor that runs after the Jamal processing is done and formats the final output as XML.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result
{%#snip:define tabulatedXmlFormat=
{%output%}%}\

{%@snip tabulatedXmlFormat
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.1</version>
</project>

----
%}

The default tabulation size is four.
You can alter it defining the user defined macro `tabsize`.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result
{%#snip:define zeroTabulatedXmlFormat=
{%output%}%}\

{%#snip zeroTabulatedXmlFormat
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<name>jamal snippet</name>
<packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId>
<artifactId>jamal-snippet</artifactId>
<version>1.7.1</version>
</project>

----
%}

As you can see there is no tabulation in this case.


There is another use of the macro `xmlFormat`.
If you do not include any XML, or anything else into the macro as input then the macro will treat this as a command to format the whole output.
I registers itself into the processor and when the processing was finished this registered call-back starts and at that point it will format the output of the processing.
That way you can easily format a whole processed file.

The rpevious example that we used before can be formulated also this way.

{%sample/
{#xmlFormat}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
%}

Note that the macro invocation `{#xmlFormat}` in this case can be anywhere in the input.
The formatting will take place postponed, when the processing is finished.
It will result the same output as before:
{%#snip:define tabulatedXmlFormat1=
{%output%}%}\

{%@snip tabulatedXmlFormat1
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.7.1</version>
</project>
----
%}

[[date]]
==== {%macroChapter%}`date`

This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

{%sample/
{@date yyyy-MM-dd HH:mm:ss}
%}

wll result the output

{%#snip:define dateOutput={%output%}%}\
{%@snip dateOutput
[source]
----
2021-02-26 15:05:27

----
%}

[[format]]
==== {%macroChapter%}`format`

The macro `format` can be used to format the arguments.
{%standardInput%}

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal all these argument are strings.
Since the parameters to the underlying `String::format` method are not only strings they can be converted.
If any of the parameters starts with a `(xxx)` string then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be

{%!@for type in (int,long,double,float,boolean,short,byte)=
* `type`, the conversion will call {%#case:cap {%@replace /type/int/integer%}%}::parse{%@case:cap type%}.%}
* `char`, the conversion will fetch the first character of the parameter.

Examples:

{%sample/
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
%}

wll result the output

{%#snip:define formatOutput={%output%}%}\
{%@snip formatOutput
[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437

----
%}

[[file]]
==== {%macroChapter%}`file`
{%@define fileDirectory($what)=
You can use this macro to include the name of a $what in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the $what, and it will appear in the output.

The real added value of the macro is that it checks that the $what exists.
If the $what does not exist or is not a $what, then the macro will error.
It helps the maintenance of the application.
If the $what gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the $what.
It uses the value of the user-defined macro `$whatFormat` for the purpose.
If this macro is defined outside the `$what` macro, then the $what names will be formatted using the same format.
For example, you can write%}\
{%fileDirectory file%}

{%sample/
When Jamal processes this file it will generate {@define fileFormat=`$name`}{@file README.adoc}.
%}

will result

{%#snip:define fileOutput={%output%}%}\
{%@snip fileOutput
[source]
----
When Jamal processes this file it will generate `README.adoc`.

----
%}

{%@define replace=|^.*?"(.*?)"|* `$1`!|!.*?//||%}\
{%@define pattern=\)\.and\(%}\
In the format you can use the following placeholders:
{%#snip:define fileMacroFormatPlaceholdersFormatted=
{%#replaceLines{%#killLines{%@snip fileMacroFormatPlaceholders %}%}%}%}

{%@snip fileMacroFormatPlaceholdersFormatted
* `$name` gives the name of the file as was specified on the macro
* `$absolutePath` the absolute path to the file
* `$parent` the parent directory where the file is
* `$canonicalPath` the canonical path
%}

[[directory]]
==== {%macroChapter%}`directory`
{%fileDirectory directory%}

{%sample/
This file is in the directory {@define directoryFormat=`$name`}{@directory ../jamal-snippet}.
%}

will result

{%#snip:define dirOutput={%output%}%}\
{%@snip dirOutput
[source]
----
This file is in the directory `../jamal-snippet`.

----
%}

In the format you can use the following placeholders:
{%#snip:define dirMacroFormatPlaceholdersFormatted=
{%#replaceLines{%#killLines{%@snip dirMacroFormatPlaceholders %}%}%}%}

{%@snip dirMacroFormatPlaceholdersFormatted
* `$name` gives the name of the directory as was specified on the macro
* `$absolutePath` gives the name of the directory as was specified on the macro
* `$parent` the parent directory
* `$canonicalPath` the canonical path
%}


[[Java]]
==== {%macroChapter%}Java Macros

[[java:class]]
===== `java:class`

{%@define classMethodMacroIntro($x)=
The macro `java:$x` checks that the parameter is a valid Java $x and can be found on the classpath.
It is an error if the class cannot be found on the classpath.
This macro can be useful when you document Java source code, and you run the Jamal conversion from a unit test.
In this case the macro will see the test and main classes.
It can check that the $x mentioned in the documentation is still there, it was not deleted or renamed.%}\
{%classMethodMacroIntro class%}

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the user defined macro `classFormat`.
For example:

{%sample/
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
%}

wll result the output

{%#snip:define class1={%output%}%}\
{%@snip class1
[source]
----
The class that implements the macro `java:class` is
ClassMacro.

----
%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=/^\s*"(.*)"\s*,\s*klass\.(.*)\(\),?$/* `$1` will be replaced by the result of calling `$2()`%}
{%#snip:define classFormatFormatted={%#replaceLines
{%@snip classFormats%}%}%}
{%@snip classFormatFormatted
* `$simpleName` will be replaced by the result of calling `getSimpleName()`
* `$name` will be replaced by the result of calling `getName()`
* `$canonicalName` will be replaced by the result of calling `getCanonicalName()`
* `$packageName` will be replaced by the result of calling `getPackageName()`
* `$typeName` will be replaced by the result of calling `getTypeName()`
%}

For example

{%sample/
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
%}

wll result the output

{%#snip:define class2={%output%}%}\
{%@snip class2
[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.

----
%}

It is not recommended to overuse the format string.
Do not include verbatim text into the format string.
Choose a format string how you want to refer to the classes and use it globally in the document.

[[java:method]]
===== `java:method`

{%classMethodMacroIntro method%}

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the user defined macro `methodFormat`.
For example:

{%sample/
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
%}

wll result the output

{%#snip:define method1={%output%}%}\
{%@snip method1
[source]
----
evaluate

----
%}

The macro can have two argument, using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>> or one specifying the full name of the method.
The full name of the method is the full name of the class and the same of the method separated by either a `#` character or by `::` characters.

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTMDC
of the method's defining class
OTM
of the method
%}
{%#snip:define methodFormatFormatted={%#replaceLines
{%@snip methodFormats%}%}%}
{%@snip methodFormatFormatted
* `$classSimpleName` will be replaced by the simple name of the method's defining class
* `$className` will be replaced by the name of the of the method's defining class
* `$classCanonicalName` will be replaced by the canonical name of the method's defining class
* `$classTypeName` will be replaced by the type name of the methodC
* `$packageName` will be replaced by the package where the method is
* `$name` will be replaced by the name of the method
* `$typeClass` will be replaced by the return type of the method
* `$exceptions` will be replaced by the comma separated values of the exception types the method throws
* `$parameterTypes` will be replaced by the comma separated parameter types
* `$parameterCount` will be replaced by the number of the parameters in decimal format
* `$modifiers` will be replaced by the modifiers list of the method
%}

These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

{%sample/
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
 {java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
%}

wll result the output

{%#snip:define method2={%output%}%}\
{%@snip method2
[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

public MethodMacro::evaluate(Input,Processor)

----
%}

[[snip:update]]
==== {%macroChapter%}`snip:update`

This macro can be used to automatically copy the content of the snippets into the `snip` macros.
That way the Jamal source will contain an updated value of the snippet helping the navigation in the Jamal source file.

The result of the macro is empty string, and it has no side effect inside the macro processor.
Whe it does, however is that it alters the file it was used in inserting the snippets into the comment part of the `snip` macro.
Its operation is done in three steps:

1. Reads the file into the memory.
2. It goes through all the lines and inserts the content of the snippet into the comment part of the `snip` macros.
If there is already a comment there then it gets deleted and replaced.
3. Writes the altered content into the original file updating it.

This macro alters the original file, therefore the use of it has to performed with great care.
Ensure that before executing Jamal you save the original file, making a copy of it or committing into the git repository.

The `snip:update` macro does not perfom Jamal syntax analysis.
To use this macro successfully you have to follow the extra rules:

* The `{@snip id...` macro should start on a new line.
There may be spaces before the macro.
There must not be a comment on the same line following the snipped identifier.
You can put a few non-space character after the snippet identifier in case you want to exclude a snippet use from the update.

* The `snip` macro matching macro closing string has to be on a separate line.
There may be spaces before and after the closing string, but nothing else.

The update macro can be customized.
If the macros `start` and/or `stop` are defined then their value will be used as regular expression to find the start and the end of the snippet content insertion points.
The default value for `start` is

    ^\s*\Q{\E\s*(?:#|@)\s*snip\s+([$_:a-zA-Z][$_:a-zA-Z0-9]*)\s*$

When this pattern is calculated the current macro opening string is used instead of `{`.
The `stop` string is

    ^\s*\Q}\E\s*$

When this pattern is calculated the current macro closing string is used instead of `}`.

(The `\Q` and `\E` escape sequences in Java regular expressions denote escaping, so that the characters between are matched literally.)

It is also possible to define a `head` and `tail` macro.
The content of the `head` macro will be copied in front of the inserted snippet.
The content of the `tail` macro will be copied after the inserted snippet.
It can be used to insert, for example asciidoc

   [source]
   ----

header and

   ----

footer when the snippets are code samples in an asciidoc file.

{%@snip:update%}
