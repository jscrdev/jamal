== Jamal Snippet Handling Macros
{%@import ../readmemacros.jim%}
Snippet handling macros help you to automatically include information from program source code into the documentation.

When you document an application there is a lot of information that changes by the change of the source code.
These changes have to be followed in the documentation.
Some changes need manual editing, some change can be automated.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
This change of the documentation can hardly be automated.
When some literal parameter also used in the document changes then the documentation can automatically be updated.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

What you see in the `README.adoc` file converted from the `README.adoc.jam` is the actual version number.
The original file however, contains

[source,xml]
----
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{{%@ident%}%VERSION%{%@ident%}}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed the snippets will automatically contain the actual text from the source code.
This way it is easier to keep your documentation up to date.

=== Usage

If you are using Jamal programmatically or from Maven then the dependency you have add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java` therefore they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

=== Macros

==== `snip:collect`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect fileName}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file then the macro will collect the snippets from that single file.
If the `fileName` is a directory then the macro will collect the snippets from the files that are in that directory and from directories beneath recursively.

A snippet in a file is aseries of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the endling line.

The regular expression contains a collection group, which will be used as the name of the snippet.
For example the code

{%@snip:collect src/test/java/javax0/jamal/documentation/Sample.java%}

[source]
----
// snippet sample
{%@snip sample%}\
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The snippet start and end matching regular expression can be redefined.
If the user defined macro `start` is defined, then the value of it will be used as snippet start matching regular expression.
If the user defined macro `stop` is defined, then the value of it will be used as snippet end matching regular expression.

The collection of the files can also be controlled using user defined macros.
The macro `include` may define a regular expression as well as `exclude`.
When they are defined only the files that match the regular expression defined by `include` and do not match by `exclude` are collected.

It is enough if the regular expressions match a part of the lines or file name.

The user defined macros may be defined inside the `collect` macro.
This is the recommended practice.
For example, the test file

[source]
----
{%@include res:javax0/jamal/snippet/test3.jam%}
----

excludes any file that contains the character `2` in its name.

[[clear]]
==== `snip:clear`

Calling ths macro deletes all collected snippets from the memory.
The result of the macro is an empty string.

[[snip]]
==== `snip`

The `snip` macro should have one argument, which should be the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip sample}
----

is replaced by the content of the snippet named `sample`.

[[properties]]
==== `snip:properties`

This macro will load properties from a "properties" file or from an "xml" file.
The names of the properties will become the names of the snippets and the values the values of the snippets.

For example the samepl

{%sample/
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
%}

{%#comment
{%output%}
%}\

will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
{%@include res:javax0/jamal/snippet/testproperties.properties%}
----

and thus using the `snip` macro, like

{%sample/
{@snip a}
%}

will result

{%output%}

If the extension of the file is `.xml` then the properties will be loaded as XML format properties.
For example the same properties file in xml format looks like the following:

[source,xml]
----
{%@include res:javax0/jamal/snippet/testproperties.xml%}
----

[[xml]]
==== `snip:xml`

This macro loads an XML file and assigns it to a "user defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

The defined `macroName` macro can be used as an ordinary user defined macro that accepts one argument.
This user defined macro evaluates in a special way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.

For example this document contains the following macros at the start:

{%sample/
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
         <version>{VERSION}</version>
...
%}

The result is:

{%output%}

which is the current version of the project as read from the `pom.xml` file.

[[trimLines]]
==== `trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When a code fragment is included into the documentation as a snippet the lines may have extra spaces at the start.
That is when the fragment comes from a code part that is somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
This way the code formatting remains the same as in the source code but the code sample will be aligned to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

{%untrimmedSample/
{@trimLines
   k
      a
     b
    c
}
%}

will result

{%untrimmedOutput%}

The macro can also delete the empty lines from the start and from the end of its input in case the option `trimVertical` is set.
For example

{%untrimmedSample/
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
%}

will result

{%untrimmedOutput%}

[[numberLines]]
==== `numberLines`

This macro can put numbers in front of the lines, sequetially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default the numbering of the lines start with one and every line gets the next number.
For example

{%sample/
{@numberLines this is the first line
this is the second line
  this is the third line
}
%}

will result

{%output%}

The number will be inserted with a `.` (dot) after the number and a space.

The user defined macros `start`, `step` and `format` can define different start value, step value and format for the numbers.
For example

{%sample/
{#numberLines {@define start=3}{@define step=2}{@define format= %03d:: }
this is the first line
this is the second line
this is the third line
}
%}

will result

{%output%}

The formatting will be used in the method `String::format`.
Any illegal formatting will result an error.