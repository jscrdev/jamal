= Jamal Json integration module
{%@options failfast%}


{%@import res:jamal.jim%}
{%#counter:define id=macroChapter {%@define format=$roman. %}%}
{%@snip:collect from=src/main/java%}
Using this integration module, you can mix Jamal macro text with JSON data.
To use this module, you have to add the dependency to your Maven project, as:
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
{%#define ARTIFACT_ID={%pom /project/artifactId/text()%}%}\

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>{%ARTIFACT_ID%}</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

Following that, you can use the
{%@define chap($x)=. <<$x,`json:$x`>>%}{%@define ImportingChapter=Importing json from a file%}

{%chap define%}
. <<import,{%ImportingChapter%}>>
{%chap get%}
{%chap set%}
{%chap add%}
{%chap dump%}
{%chap output%}

{%@define chap($x)=[[$x]]
=== {%macroChapter%}`json:$x`
%}{%@define link($x)=<<$x,`json:$x`>>%}
macros.
This macro package was created refactoring the original `jamal-yaml` macro library.
During the development we created the macros so that they can be used in similar manner to Yaml macros.
Although we tried to be as close to the structure of the Yaml macros, there are differences.
These differences come from the different nature of Json and Yaml.

== Macros implemented in the package

{%chap define%}

You can use this macro to define a JSon structure.
A JSON structure can be a map, a list or a string.
JSon supports other primitive values, but Jamal being a text macro processor handles all other primitive types as strings.

The format of the macro is

[source]
----
{@json:define jsonMacro=
tabulated JSON content
}
----

After that, the name `jsonMacro` will be defined as a user-defined macro and can be used as `{jsonMacro}` without argument.
The value will replace the place of the use with the actual unformatted JSON content.

NOTE: Internally, Jamal converts the JSON read in an object structure consisting of strings, primitives, maps, and lists.
The structure is stored in an object of the type {%@java:class (format=`$simpleName`) javax0.jamal.json.JsonMacroObject%}.
This class technically is a user-defined macro.
The `json:define` macro will register the structure among the user-defined macros.
When the name is used the same way as any other user-defined macro (without any argument), the content of the JSON structure is converted to text.

The `jsonMacro` is stored along with the "usual" user-defined macros.
Any usual or other user-defined macro can be redefined any number of times.
If you want to define a JSON macro only if it was not defined prior, use the `?` after the keyword `json:define`.
If you want to get an error message if the macro was already defined, use the `!` after the keyword `json:define`.
This functionality is implemented the same way as it is for the core built-in macro `define`.

The core `define` macro also has options to drive these behaviour.
The `json:define` macro does not.

The example:

{%sample/
{@json:define xyz={
a: this is the string value of a,
b:[ first value of b,second value in b],
c: {a: this is c.a,b: this is c.b}}
}\
{xyz}
%}

will result

{%output%}

The advantage of using this macro over just writing the JSON directly to the output is that:

* You can use user-defined macro parameters mixing the json content with Jamal macros.

* You can modify the structure using the `json:set` macro.

Utilizing user-defined macros, you can use macros inside JSON code, and at the same time, you can use JSON code inside the macros.
That way, you can pull out the part, repeat, and use only the macro as a reference.

[NOTE]
====
When processing JSON input, you can use the `{` and `}` characters as macro opening and macro closing strings.
These characters are paired in the JSON input, therefore they will not interfere with the macro processing.
That is only if we assume that the JSON containing macros do not contain macros themselves, and they are invoked using the `@` in front of their name.
However, when there is a need to evaluate macros before interpreting the JSON, the `{` and `}` characters may cause problems.
You can overcome this setting the macro opening and closing stings to something else, like `{%%}` and `%}`.
You can also modify the JSON using `{}` in place of every `{` and a `}` in place of every `}`.
This will disturb the balance of the `{` and `}` characters, that may hinder some editor navigation.
You can also use the `{@ident...}` to protect the parts that are pure JSON content without macros.

The recommended way is to use something different than `{`and `}` as macro opening and closing strings.
====

[[Import]]
==== {%macroChapter%}{%ImportingChapter%}

{%#define RES($x)={%#if |{%@env intellij.asciidoctor.plugin?%}|../jamal-test/src/test/resources/|res:%}$x%}
There is no special include macro to read JSON formatted data from a file.
If you want to read data from a file, you should combine the `json:define` and the core `include` macros.
For example, there is a resource file {%@file (format=`$name`) src/test/resources/sample_verbatim.json%} in the project where this documentation is compiled.
It can be referenced from the test execution, which also converts this document including `res:sample_verbatim.json`.
The content of this file is

{%sample {%#include [verbatim] {%RES sample_verbatim.json%}%}%}

You can use the following structure to read it from the file and assign the JSON data to the macro `aqt`:


{%sample/
{#json:define aqt={@include [verbatim] res:sample_verbatim.json}}
{aqt}
%}
{%#block{%sample/
{#json:define aqt={@include [verbatim] {%RES sample_verbatim.json%}}}
{aqt}%}%}

which will result

{%output%}

The file has to be a JSON formatted file, and it should not contain any Jamal macro.
(If it does, it will be treated as raw data and will not be macro processed by Jamal.)
If you want to read a Jamal formatted JSON file, you must include it using the core `include` macro without the `[verbatim]` option.

NOTE: The built-in core macros use the `[` and `]` characters to enclose the options.
Other packages usually use `(` and `)`.

The file {%@file (format=`$name`) src/test/resources/sample.json.jam%} contains Jamal macros:

{%sample/
{%#include [verbatim]{%RES sample.json.jam%}%}
%}

You can include it with evaluation using the following macro sequence.

{%sample/
{@define a=wuff wuff}
{#json:define h={@include res:sample.json.jam}}
{h}
%}
{%#block
{%sample/
{@define a=wuff wuff}
{#json:define h={@include {%RES sample.json.jam%}}}
{h}
%}%}

which will result:

{%output%}

NOTE: The included file starts with the `{@` characters.
Files starting with these two characters are included or imported changing the macro opening anc closing string to `{` and `}`.
The first macro in this file, however, changes the macro opening string to be `/` and the closing string to be `.` (dot).
That way the JSON map structure is not interpreted as macro, but the `/a.` is.
This is an extreme demonstration purpose example.
The recommended way is to use `{%%}` and `%}` as macro opening and closing strings.

{%chap get%}

This macro will fetch one value from a JSON structure.
This can be useful when you want to document some configuration or other data structure that is present as a JSON file in your project.
In that case you can import the JSON structure into your Jamal document and refer individual values in it.
The format of the macro is:

{%sample/
{@json:get (from=jsonMacro) JSONPointer}
%}

The option `from` names a JSON user defined macro, where the JSON structure was loaded.
It can also be defined outside as a user defined macro of the name `jsonDataSource`.
This is useful when you want to retrieve multiple values from the same data structure.

The `JSONPointer` is navigational path documented in the link:https://stleary.github.io/JSON-java/org/json/JSONPointer.html[JavaDoc] api of the JSON library this macro package uses:

> A JSON Pointer is a simple query language defined for JSON documents by RFC 6901. In a nutshell, JSONPointer allows the user to navigate into a JSON document using strings, and retrieve targeted objects, like a simple form of XPATH. Path segments are separated by the '/' char, which signifies the root of the document when it appears as the first char of the string. Array elements are navigated using ordinals, counting from 0. JSONPointer strings may be extended to any arbitrary number of segments. If the navigation is successful, the matched item is returned. A matched item may be a JSONObject, a JSONArray, or a JSON value. If the JSONPointer string building fails, an appropriate exception is thrown. If the navigation fails to find a match, a JSONPointerException is thrown.

When getting a value out of a JSON user defined macro the macro will automatically be resolved.

===== Examples

{%sample/
{@json:define a={a:"alma",b:2,c: 3,d:[1,2,{q:{h:"deep h"}}]}}\
{@json:get (from=a) /d/2/q/h}
{@json:get a./d/2/q/h}
%}

will result

{%output%}

As you can see from the example, when the `from` option is missing, the macro will interpret the first part of the pointer until the `.` dot character as the macro name.

{%chap set%}

The macro `json:set` can define a json user defined macro from an already existing json macro.
It is similar to `json:define` but this macro does not parse a text and interpret it as json formatted text.
Instead, it uses an already defined json user defined macro and uses some part of it, and it assigns that to a new user defined macro name.
This JSON assigned to a new macro name is NOT a copy.
If you use the macro `json:add` adding element to the JSON structure, the original JSON structure will be modified.

The syntax of the macro is

{%sample/
{@json:set (from=macro) macroName=JSONPointer}
%}

There is one option the same way as with the macro `json:get`:

* `jsonDataSource` (alias `from`) the name of the user defined macro which is the source of the data

If the `from` value is missing then the macro interprets the `JSONPointer` expression using the start of it as the name of the macro.
It has to have the form `macroname.` at the start.
The identifier until the `.` is used as the name of the macro from which the data is to be fetched.
The `macroName` is the name of the macro to assign the new object value.

===== Example

{%sample/
{@json:define a={a:"alma",b:2,c: 3,d:[1,2,{q:{h:"deep h"}}]}}\
{@json:set s=a./d/2/q/h}
{@json:set (from=a) r=d/2/q/h}
{s}
{r}
%}

will result

{%output%}

NOTE: A JSONPointer expression must start with the `/` or `#/` characters.
The Jamal macros will prepend the `/` character to the expression if it is missing.
That way the text is less noisy.

{%chap add%}

The macro `json:add` can modify an already parsed JSON data structure.
You can add elements to lists or maps inside the JSON structure.
The syntax of the macro is

{%sample/
{@json:add options
json data structure
}
%}

The json data structure is the textual representation of the JSON data to be hooked on the already existing data structure.
The options present on the same line as the macro keyword `json:add` and the json data structure starts on the second line.
The possible options are:

* `jsonDataTarget` (alias `to`) must be specified and should define the point where the new data structure is added.
The keyword `jsonDataTarget` can also be a user defined macro.
The alias `to` can only be used in the macro use.
Using `jsonDataTarget` defined as a user-defined macro makes sense when there are several additions to the same point.
The format of the option is `macroName.JSONPointer expression`.
The name of the macro that holds the current data structure to be modified is at the start of the `to` string.
It is separated by a `.` dot character from the JSONPointer expression that identifies the part of the structure to be modified.
If there is no `.` in this parameter then the root of the structure is used.

* `key` should only be specified when adding new data to a `Map`.
The value of this option will be the key used in the `Map`.
If data with the key already exists it will be overwritten.
It is an error to specify a `key` when adding value to a data point, which is a list.
It is also an error to specify the `key` when the option `flat` is specified.
In this case the keys of the map will be used.

* `flat` or `flatten` will decompose the JSON structure before adding to the data point in the original json.
Adding values to a `Map` then the top level of the JSON structure to be added also has to be `Map`.
Adding values to a `List` then the top level of the JSON structure to be added also has to be `List`.
Adding a `Map` this way the key value pairs of the map will be added to the original JSON map.
Adding a `List` this way the values of the list will be appended to the original JSON list.
When this option is specified it is an error to specify any `key` since in this case the keys of the map will be used.

==== Examples

===== Adding a value to the top level Map

This example adds a new value to the root of the JSON structure.

{%sample/
{@json:define a={a: "this is a simple JSON with a top level Map"}}
{@json:add to=a key=b
"this is the value to be added to json structure a"}
{a}
%}

will result:

{%output%}

===== Adding element to a Map in the JSON structure

In this example the value is added to the value of the map from the top level named `b`.

{%sample/
{@json:define a={"a": "this is a simple JSON with a top level Map","b":{}}}
{@json:add to=a.b key=c
"this is the value to be added to json structure a"}
{a}
%}

will result:

{%output%}

===== Using flat to add multiple elements to a Map

This example will add multiple elements to a map inside the json structure.

{%sample/
{@json:define docker={
version: "3.6",
services: ["http","https","jamal-debug"],
zilch: { "nada": "nothing" }
}}\
{@json:set wuff=docker./services}
{@json:add to=docker./services flat
[{
"com.javax0.jamal.title": "Non-relational DB Instance",
"com.javax0.jamal.sizing": 1000,
"com.javax0.jamal.nodeType": "primary"
}]
}
docker: {docker}

Note that wuff also changed: {wuff}
%}

will result:

{%output%}

===== Adding elements to an array

This example adds one element to an array.
The added element itself is an array.
It is not flattened

{%sample/
{@json:define a=["this is a simple JSON with a top level Map","kukuruc"]}
{@json:add to=a
["this is one element","this is the second element"]}
{a}
%}

will result:

{%output%}

If we use flattening we get different result

{%sample/
{@json:define a=[this is a simple JSON with a top level Map,kukuruc]}
{@json:add to=a flatten
[this is one element,this is the second element]}
{a}
%}

will result:

{%output%}


{%chap output%}

The macro `json:output` redefines the output of the Jamal processing.
The format of the macro is:

{%sample/
{@json:output jsonMacro}
%}

Here the `jsonMacro` is the name of a JSON macro to be rendered as the final output of the Jamal processing.
It has to be defined at the end of the processing.
It also means that this macro has to be on the top level in the macro hierarchy.
In other words, it has to be a global macro.

When this macro is used, the output of the Jamal processing will be the JSON formatted structure of the data held in the macro `jsonMacro`.
