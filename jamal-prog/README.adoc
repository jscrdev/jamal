= Jamal Prog Macro Module

The prog macro extends Jamal to execute a simple BASIC like programming language.

Using this integration module you can mix Jamal macro text with simple, imperative code snippets.
To use this module you have to add the dependency to your Maven project, as:


[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-prog</artifactId>
    <version>2.0.3-SNAPSHOT</version>
</dependency>
----

Note that this dependency is added to the different Jamal integrations.
This module is available automatically when you use Jamal in Maven extension, JavaDoc, through JBang, or in the IntelliJ Asciidoctor plugin.

The language is a subset of the BASIC language, and it is very simple by design.
It is far simpler than ScriptBasic, Ruby or Groovy, which are also integrated into Jamal by other modules.
On the other hand it is tightly integrated into Jamal.
The other programming modules allow nesting programming code into Jamal text and then use macros to manage the input and the output of the snippets.
This module allows nesting code into Jama and the other way around.
Program code can also include Jamal macros.
Also, there is no need for extra macros to manage the input and the output of the code.
The code uses the same symbolic names as the Jamal macros, and the output of the code is directly the output of the code macro.

The language is a subset of the BASIC language, and it is very simple.
There are only a few commands that you can use:

* variable assignment

* if-then-else

* for loops

* while loops

* output, denoted by `<<`

* comment following `rem` or an `'` character till the end of the line

Expressions can contain

* the basic operations: `+`, `-`, `*`, `/`, `%`,
* comparisons `==`, `!=`, `<`, `>`, `<`=`, `>=`
* logical operations `and`, `or`, `not`
* and parenthesis.

In addition to these there is a special operator `!` used to start evaluation of Jamal macros in strings.

== Macros in the Package

There are two macros in the package:

* `program` is the macro that executes a program
* `expression` is the macro that evaluates an expression

=== Program

The macro `program` takes the input of the macro and interprets it as a program.
The result of the macro is the concatenated strings of the output `<<` commands.

For example:

[source]
----
{@program
     <<"this is the output "
     <<"of the program "
     ' here we start a loop
     for i=1 to 2
     rem this is also a comment
     <<"and it is,.. "
     next ' I can write comments at the end of the line
     <<"concatenated "
     <<"together "
} 
----

will result in the output:

[source]
----
this is the output of the program and it is,.. and it is,.. concatenated together  
----


The language is very simple, documented below in the section about expressions, and commands.

The command `program` has the option `stepLimit`.
This parameter has to be a number.
It limits the number of steps that the program can execute.
When the limit is reached the program will throw an exception.
The default value of the limit is 100000 (hundred-thousand).
This limit is to prevent infinite loops.


[source]
----
{@try! {@program stepLimit=18
<<"this is the output "
<<"of the program "
for i=1 to 2
<<"and it is,.. "
next
<<"concatenated "
<<"together "
}} 
----

will result in the output:

[source]
----
Step limit reached 
----


[%collapsible,title=How the steps are counted]
====
Each code "block" is calculated a step, each individual command is calculated as a step and each operation in an expression is calculated as a step.
In the example above the steps are

[start=0]
. program start counts as one step
. the first `<<`
. accessing the constant string value
. the second `<<`
. accessing the constant string value
. starting the for loop
. accessing constant `1` for the start value
. accessing constant `2` for the end value
. accessing constant `1` for the step value, which is implicit, still accessing it is a step

. starting the code block of the for the first loop execution
. the first execution `<<` in the for loop
. the access to the constant string value in the first loop execution

. starting the code block of the for the second loop execution
. the second execution `<<` in the for loop
. the access to the constant string value in the second loop execution
. accessing the constant string value
. the `"concatenated "` `<<` fater the loop has finished
. accessing the constant string value
. the `"together "` `<<`
. accessing the constant string value

The command `next` does not calculate.
That command is just a marker for the end of the loop, and it is used by the syntax analyser.
If you change the `stepLimit` to 19 then the program will succeed.
====

The macro also supports the `do` and `run` aliases.

=== Expression

The macro `expression` takes the input of the macro and interprets it as an expression.
The result of the macro is the value of the expression.


== Expression Syntax

Expressions are composed of numeric constants, strings, variables and operators.
The operators are the basic arithmetic operators, the comparison operators, the logical operators and the `!` operator.

The formal syntax of the expressions is:

  expression ::= expression1 `and` expression |
                 expression1 `or` expression |
                 expression1

  expression1 ::= expression2 `==` expression |
                  expression2 `!=` expression |
                  expression2 `<` expression |
                  expression2 `>` expression |
                  expression2 `<=` expression |
                  expression2 `>=` expression |
                  'not' expression1 |
                  expression2

    expression2 ::= expression3 `+` expression |
                    expression3 `-` expression |
                    expression3

    expression3 ::= expression4 `*` expression |
                    expression4 `/` expression |
                    expression4 `%` expression |
                    expression4

    expression4 ::= `!` expression |
                    `(` expression `)` |
                    number |
                    string |
                    variable |
                    '+' expression4 |
                    '-' expression4

The different operations are executed using BigDecimal numbers if the operands are both numeric.
In other cases string operations are used.
In this case `-`, `*`, `/` and `%` are not defined and will cause syntax error.
`+` is defined as string concatenation.
When used as unary `+` it is a no-op resulting the same string as the operand.

The operator `!` is used to evaluate a Jamal macros.
It is applied to the expression that follows it, and it evaluates it as string.

This evaluation is done in the same scope as the surrounding environment.
If you `define` here a macro then it will be available in the surrounding environment.
There is no need to `export` the macro.

The same is ture for the variables.
If you assign a value to a variable here then it will be available in the surrounding environment as a macro.
The other way around, if you assign a value to a macro in the surrounding environment then it will be available in the program as a variable.
Such macros must not have parameters.

The following code uses two macros.
One with parameter and it is used in a `try` block to catch the exception.
The other macro, `b` has no parameter, and it can be used in the program.

The macro `b` is used as a variable, and it is outputted from the program.
It is also modified.
The character `1` is appended to the string.
The variable `evil` is not defined in the program, but it is used outside.

[source]
----
{@define a(x)=this is x}
{@define b   =this is b}
{@try! {@program
            <<a}}
{@program
     <<b + !"{a A}"
     b = b + 1
     evil = 666
} {b}
{evil}
----

[source]
----
Macro 'a' needs 1 arguments and got 0
this is bthis is A this is b1
666
----


== Commands

The interpreted language has only a very few commands.
These are

* variable assignment
* if-then-else
* for loops
* while loops
* output

In the following chapters we will discuss these commands.

=== variable assignment

The variable assignment has the form:

    variable = expression

The name of the variable can be any string, which is a valid Jamal user defined macro name.
The value of the expression will be treated as a string and will be stored in the macro registry.

[source]
----
{@program
     :z = 13
     b = z + 17
}{b}
----

will result

[source]
----
30
----


The variable `:z` is registered in the global macro scope.
It can later also be referenced as `z` unless there is a variable `z` in a lower scope.

=== if-then-else

If-then-else has the form:

    if expression then
        block
    elseif expression then
        block
    else
        block
    endif

The `else` and `elseif` parts are optional.
The interpretation of the commands is the conventional.

[source]
----
{@program
if "true" then
    <<"if true"
elseif true then
    <<"elseif true"
else
    <<"else"
endif
}
----

will result

[source]
----
if true
----


You can write `endif` and `elseif` as `end if` and `else if`.

=== for loops

For loops execute the lines between the `for` and `next` commands.

[source]
----
{@program
for i=0 to 9 step 1
    <<i
next
}
----

will output

[source]
----
0123456789
----


The `step` part is optional.
The values are evaluated when the loop is started.
The `step` value can be negative.

Note that the for loop uses the same operation as `+`.
It means, if some values are strings then the loop will concatenate the step value.
Unfortunately, in this case the loop cannot terminate.

=== while loops

[source]
----
{@program
i = 0
while i < 10
    <<i
    i = i + 1
wend
}
----

will result

[source]
----
0123456789
----


=== output

The output command, as you could see examples in the previous samples, is the `<<` command.
The expression after the `<<` is evaluated and the result is appended to the result of the program macro.

[source]
----
{@program
   a = "{@define z=55}"
   a = !a
   <<a
   <<z

} {z}
----

[source]
----
55 55
----

