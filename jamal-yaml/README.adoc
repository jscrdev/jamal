= Jamal Yaml integration module




Using this integration module, you can mix Jamal macro text with YAML data.
To use this module, you have to add the dependency to your Maven project, as:

[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-yaml</artifactId>
    <version>1.7.4</version>
</dependency>
----

Following that, you can use the


. <<define,`yaml:define`>>
. <<ref,`yaml:ref`>>
. <<resolve,`yaml:resolve`>>
. <<import,Importing yaml from a file>>
. <<get,`yaml:get`>>
. <<dump,`yaml:dump`>>
. <<output,`yaml:output`>>


macros.

== Macros implemented in the package

[[define]]
=== i. `yaml:define`


You can use this macro to define a Yaml structure.
The format of the macro is

[source]
----
{@yaml:define yamlMacro=
tabulated Yaml content
}
----

After that, the name `yamlMacro` will be defined as a user-defined macro and can be used as `{yamlMacro}` without argument.
The value will replace the place of the use with the actual Yaml content.

NOTE: Internally, Jamal converts the Yaml read in an object structure consisting of strings, primitives, maps, and lists.
The structure is stored in an object of the type `YamlObject`.
This class technically is a user-defined macro.
The `yaml:define` macro will register the structure among the user-defined macros.
When the name is used the same way as any other user-defined macro (without any argument), the content of the Yaml structure is converted to text.

The example:

[source]
----
{@yaml:define xyz=
a: this is the string value of a
b:
  - first value of b
  - second value in b
c:
  a: this is c.a
  b: this is c.b
}\
{xyz}
----

will result

[source]
----
a: this is the string value of a
b: [first value of b, second value in b]
c: {a: this is c.a, b: this is c.b}
----


The advantage of using this macro over just writing the Yaml directly to the output is that:

* you can split up the Yaml file into smaller pieces using the <<ref,`yaml::ref`>>, and <<resolve,`yaml::resolve`>> macros,

* you can use user-defined macro parameters mixing the yaml content with Jamal macros.

Many times Yaml structures become overly profoundly nested, and it is not trivial to move things around.
The Yaml structure is a data description structure, and many times these data structures are redundant.
When editing Yaml structures, it is common to copy some part of the structure and edit its art.
Using Jamal, you can solve the indentation hell as well as you can reduce the poisonous redundancy.
Utilizing user-defined macros, you can use macros inside Yaml code, and at the same time, you can use Yaml code inside the macros.
That way, you can pull out the part, repeat, and use only the macro as a reference.

It is a solution for strings and parts of some strings used at multiple locations in the Yaml file.
User-defined macros alone do not solve the problem of overcomplexity and deep tabulation.

The Jamal Yaml module allows you to have a partially defined Yaml file to overcome this problem.
When a Yaml structure is read from the text representation, it is stored in the memory as a Java object structure.
It utilizes primitive values, strings, lists, and maps.
In addition to that, you can also use

[source,yaml]
----
!!java.class.Name value
----

type of values that will tell the Yaml reader to create a value stored in an object of the class `java.class.Name`.
It can only be used when the specified class is on the classpath, and it is rarely used in general Yaml.
There is a particular class in the `javax0.jamal.api` package, called `Ref`.
When you specify a value

[source,yaml]
----
!!javax0.jamal.api.Ref xyz
----

it will create a `new Ref(xyz)` object.
Jamal will interpret this object as a reference to another Yaml data structure stored as a user-defined macro with the name `xyz`.
When you specify the Yaml structure, the user-defined macro `xyz` does not need to be defined yet.
It may be defined, but it may also be defined later.
What is more, the macro can also be the same as the one that contains it.
These references can be recursive.

The example:
[source]
----
{#yaml:define b=- x
- y
- {@yaml:ref a}}
{@yaml:define a=[a,b,c]}
{b}
----

results

[source]
----
- x
- y
- !!javax0.jamal.api.Ref {id: a}
----


You can also write this example as

[source]
----
{@yaml:define b=- x
- y
- !!javax0.jamal.api.Ref a}{@comment DON'T DO THIS!}
{@yaml:define a=[a,b,c]}
{b}
----

resulting in the same output

[source]
----
- x
- y
- !!javax0.jamal.api.Ref {id: a}
----


NOTE: You can notice that the macro `a` referenced from `b` is defined later than `b`.

Having these references with Jamal specific class types is of no general use.
Their value is that Jamal can resolve them by converting the references to the content of the named macro.
When you invoke the built-in macro `yaml:resolve`, these references will be replaced with their actual value.

The same example as above, but resolving the Yaml macro before using it

[source]
----
{#yaml:define b=- x
- y
- {@yaml:ref a}}
{@yaml:define a=[a,b,c]}
{@yaml:resolve b}
{b}
----

will result

[source]
----
- x
- y
- [a, b, c]
----


When you invoke `yaml:resolve`, all the referenced Yaml macros have to be defined.

Using this reference possibility, you can have several small Yaml fragments possibly referencing each others using the `!!javax0.jamal.api.Ref`.
When the small segments are done, you can apply `yaml:resolve` on the root one and create the output.

[NOTE]
====
When processing Yaml input, you can use the `{` and `}` characters as macro opening and macro closing strings.
When you edit a Yaml file, you do not usually use the JSON-compatible `{ ... }` format for mapped values.
However, when you use a user-defined, named Yaml content, like `{yamlMacro}`, it is likely to happen that the underlying rendering will generate a textual representation of the Yaml data, which contains `{` and `}` characters.
The values of the user-defined macros are evaluated after they were dereferenced.
The Yaml macros are exempt from this.
These user defined macros are defined verbatim, like a normal user defined macro was defined using the `~` character after the `define` keyword.
The evaluation is not needed because Yaml data hardly ever contain Jamal macros to be processed.
The `{` and `}` characters may also cause a problem for Jamal.
Precisely, it would interpret the first identifier following the `{` character as a user-defined macro.
It will not find it.
Even if it found it, it would not likely to properly evaluate.

One solution to this problem is to use a different opening and closing string that does not appear inside the Yaml output.
If you can find one for your application, you can go for it.
Usually, you cannot guarantee that none of the string fields will contain the macro opening string.
The safe solution is that these macros are defined my the Yaml built-in macros as verbatim.
If you need to evaluate the content of the Yaml structure with embedded macros you have to use the `{!yamlMacro}` format.

For more information on macro evaluation order, see the core documentation of Jamal.
====

[[ref]]
=== ii. `yaml:ref`


Use this macro to reference another Yaml definition.
The implementation of a reference is an object, instance of the class `javax0.jamal.api.Ref`.
It, however, is a Java-specific way.
You can reference another user defined Yaml definition in the form:

[source]
----
{@yaml:define x=
a: this is a string
b: !!javax0.jamal.api.Ref xyz}
----

It is more readable if you write:

[source]
----
{#yaml:define x=
a: this is a string
b: {@yaml:ref xyz}}
----

NOTE: In this case, the `{\#yaml:define...}` macro starts with the `#` character because the macro `{@yaml:ref...}`, inside it, has to be evaluated.

There is no guarantee that the implementation to reference another named, user-defined Yaml fragment will be compatible with the current implementation.
Using the `yaml:ref` macro is the safe approach because it will always generate the Yaml reference sequence recognized by `yaml:resolve`.

[[resolve]]
=== iii. `yaml:resolve`


Use this macro to resolve one or more user-defined Yaml macro.

The format of the macro is

[source]
----
{@yaml:resolve macroName1, macroName2, ..., macroNameX}
----


User-defined Yaml macros created using the <<define,`yaml::define`>> or <<import,`yaml::import`>> macros may reference other user-defined Yaml macros.
When you invoke the macro `yaml:resolve`, it will replace the references in the Yaml macro content with the content of the Yaml macro it references.
The resolving process is recursive.
If there are any references in the referenced Yaml macro, it will also be resolved.
After resolving a macro `xyz` that references the macro `aqt`, the macro `aqt` will also be resolved.
In some rare cases, this should not happen.
If the referenced Yaml macros should not de resolved, then the option `yamlReferenceClone` should be set using the macro `{@option yamlReferenceClone}`.
This option also has a local parameter alias, `clone`, that can be used between `(` and `)` as a macro option.

The example

[source]
----
{@yaml:define a=[ a, b ,c ]}
{#yaml:define aqt=z: {@yaml:ref a}}
{#yaml:define xyz=
a: 1
b: 3
c: {@yaml:ref aqt}}
{@yaml:resolve (clone) xyz}
Resolved:
{xyz}
Not resolved:
{aqt}
----

will result

[source]
----
Resolved:
a: 1
b: 3
c:
  z: [a, b, c]

Not resolved:
z: !!javax0.jamal.api.Ref {id: a}
----


This process will not change the value of the macro `aqt`.
In this case, the resolving process will create a copy of the referenced macro, and it will resolve the copy recursively.
That way, `xyz` is still fully resolved and ready to be used.

The same example doing the resolve without the `clone` option, however

[source]
----
{@yaml:define a=[ a, b ,c ]}
{#yaml:define aqt=z: {@yaml:ref a}}
{#yaml:define xyz=
a: 1
b: 3
c: {@yaml:ref aqt}}
{@yaml:resolve xyz}
Resolved:
{xyz}
Also resolved:
{aqt}
----

will result

[source]
----
Resolved:
a: 1
b: 3
c:
  z: [a, b, c]

Also resolved:
z: [a, b, c]
----


NOTE: When a macro is resolved, it will remember that it was already resolved and will not execute the resolve process anymore.
It also means that calling `yaml:resolve` with the `clone` option on `xyz` and then calling it again without it will not resolve the referenced `aqt`.
Unless you have a specific need, use the `yaml:resolve` macro without cloning.

There is another option that alters the behaviour of the resolving process.
This is `yamlResolveCopy` with the alias `copy`.
This option creates a copy of the referenced structures, cloned or not.
To understand this we can have a look at the following example:

[source]
----
{@yaml:define a=[ a, b ,c ]}
{#yaml:define aqt=z: {@yaml:ref a}
y: {@yaml:ref a}
}
{@yaml:resolve aqt}
{aqt}
----

will result

[source]
----
z: &id001 [a, b, c]
y: *id001
----


When the underlying Snake Yaml library generates the text format of the Yaml data it realizes that both `z` and `y` fields refer to the same object.
Thus SnakeYaml generates a label, something like `&id001` at the first occurrence and instead of repeating the same structure it on second occasion it only references that as `*id001`.
The resolving process can circumvent this creating a copy for every reference.

[source]
----
{@yaml:define a=[ a, b ,c ]}
{#yaml:define aqt=z: {@yaml:ref a}
y: {@yaml:ref a}
}
{@yaml:resolve (copy) aqt}
{aqt}
----

will result

[source]
----
z: [a, b, c]
y: [a, b, c]
----


Note that `copy` and `clone` are not the same.
You can use the `clone` option together or without `copy` and also the other way around.
The implementation of copy resolution can handle recursive data structures and it will generate references into the output.

For example

[source]
----
{#yaml:define a=[ a, b ,c, {@yaml:ref a}]}
{@yaml:resolve (copy clone) a}
{a}
----

works as expected

[source]
----
&id001
- a
- b
- c
- *id001
----


However, when trying to resolve the following:

[source]
----
{#yaml:define a=[ a, b ,c, {@yaml:ref a}, {@yaml:ref a}]}
{@try! {@yaml:resolve (copy clone) a}}
{a}
----

then the result is

[source]
----
There is a recursive data structure while using the copying resolution.
- a
- b
- c
- !!javax0.jamal.api.Ref {id: a}
- !!javax0.jamal.api.Ref {id: a}
----


Here we got an error message from the macro `try`, and the Yaml structure stored in `a` remained unresolved.

[[Import]]
==== iv. Importing yaml from a file

There is no import macro to read Yaml formatted data from a file.
If you want to read data from a file, you should combine the `yaml:define` and the core `include` macros.
For example, there is a resource file `src/test/resources/sample.yaml` in the project where this documentation is compiled.
It ren be referenced from the test execution, which also converts this document as `res:sample.yaml`.
The content of this file is

[source]
----
# this is a sample Yaml file that the test TestImport imports
# note that this file is a pure YAML file and no Jamal macros are in it
&id
a: this is a
b: this is b
c:
  - 1
  - 2
  - 3
  - 5
q: *id
----

You can use the following structure to read it from the file and assign the Yaml data to the macro `aqt`:

[source]
----
{#yaml:define aqt={@include [verbatim] res:sample.yaml}}
{aqt}
----

which will result

[source]
----
&id001
a: this is a
b: this is b
c: [1, 2, 3, 5]
q: *id001
----


The file has to be a Yaml formatted file, and it should not contain any Jamal macro.
(If it does, it will be treated as raw data and will not be macro processed by Jamal.)
If you want to read a Jamal formatted Yaml file, you must include it using the core `include` macro without the `[verbatim]` option.

NOTE: The built-in core macros use the `[` and `]` characters to enclose the options.
Other packages usually use `(` and `)`.

The file `src/test/resources/sample.yaml.jam` contains Jamal macros:

[source]
----
# this is a sample Yaml file that the test TestImport imports
# note that this file is a pure YAML file and no Jamal macros are in it
# contains user defined macro reference `a`
&id
a: this is {a}
b: this is b
c:
  - 1
  - 2
  - 3
  - 5
q: *id
----

You can include it with evaluation using the following macro sequence.

[source]
----
{@define a=wuff wuff}
{#yaml:define h={@include res:sample.yaml.jam}}
{h}
----

which will result:

[source]
----
&id001
a: this is wuff wuff
b: this is b
c: [1, 2, 3, 5]
q: *id001
----


[[get]]
=== v. `yaml:get`


This macro will fetch one value from a Yaml structure.
This can be useful when you want to document some configuration or other data structure that is present as a Yaml file in your project.
In that case you can import the Yaml structure into your Jamal document and refer individual values in it.
The format of the macro is:

[source]
----
{@yaml:get (from=yamlMacro) OGNL-PATH}
----

The option `from` names a Yaml user defined macro, where the Yaml structure was loaded.
It can also be defined outside as a user defined macro of the name `yamlDataSource`.
This is useful when you want to retrieve multiple values from the same data structure.

The `OGNL-PATH` is a Object Graph Navigation Library Path.
The functionality to fetch a value is implemented using the Apache Commons OGNL library.
For more information about the OGNL language visit the web site https://commons.apache.org/proper/commons-ognl/index.html.

When getting a value out of a Yaml user defined macro the macro will automatically be resolved.
The resolution can be cloning or in-place.
To control the resolution process the same options can be used as for the <<resolve,`yaml::resolve`>> macro.

===== Examples

[source]
----
{@yaml:define a=
a: alma
b:
  c: 3
  d:
    - 1
    - 2
    - q:
        h: deep h}
{@yaml:get (from=a) b.d[2].q.h}
----

will result

[source]
----
deep h
----


[[dump]]
=== vi. `yaml:dump`


The macro `yaml:dump` can dump the Yaml data structure to a file.
The format of the macro is

[source]
----
{@yaml:dump yamlMacro to file_name}
----

where `yamlMacro` is the name of the macro that holds the Yaml data structure.
`file_name` is the name of the file where the Yaml formatted content is to be written.
The `to` separating them is a keyword to ease readability.
The following structure presents an example:

[source]
----
{@yaml:define x=[a,b,c]}
{@yaml:dump x to ./target/dump.yaml}
{@include [verbatim] ./target/dump.yaml}
----

will result

[source]
----
[a, b, c]
----


There is no reason to dump an unresolved structure into a file.
If the macro to be dumped to the file was not yet resolved, it will be resolved.
The resolution process will be in-place unless the option `yamlResolveClone` (alias `clone`) is used before the name of the macro between `(` and `)` characters.

[source]
----
{@yaml:dump (clone) x to ./target/dump.yaml}
----


[[output]]
=== vii. `yaml:output`


The macro `yaml:output` redefines the output of the Jamal processing.
The format of the macro is:

[source]
----
{@yaml:output yamlMacro}
----

Here the `yamlMacro` is the name of a Yaml macro to be redered as the final output of the Jamal processing.
It has to be defined at the end of the processing.
It also means that this macro has to be on the top level in the macro hierarchy.
In other words, it has to be a global macro.

When this macro is used, the output of the Jamal processing will be the Yaml formatted structure of the data held in the macro `yamlMacro`.
If this macro contained references and was not yet resolved, then it will be resolved.
Since this is the last step processing the whole Jamal structure following the entire process, usually there is no need for cloning.
If for any reason there is need for cloning then the `clone` option may be used on the command.
The command also supports the `copy` option.